<!doctype html>











<html lang="en">
  <!-- The Head -->

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta
    name="viewport"
    content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover"
  >

  

  

  
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Saga Pattern with serverless model on Google Cloud Platform - Part 1" />
<meta name="author" content="Lahiru Pathirage" />
<meta property="og:locale" content="en" />
<meta name="description" content="Gostep: ðŸ‘‰ Guide Materials: ðŸ‘‰ Complete source code During the past few years, the microservices architecture(MSA) and serverless model have gained a lot of popularity in the industry. However, these technologies come with their own set of challenges. One substantial challenge is managing data in MSA due to its complexity. Considering common patterns for MSA data management we will be focusing on the Saga pattern in this article. The Saga pattern In order to manage business transactions across multiple microservices, the Saga pattern was introduced. Basically it is a series of local transactions; every transaction happens within the boundary of the micro-service, which every service will publish an event after the transaction for the next subsequent micro-service to perform the next transaction consuming the published event. This process will continue till the last transaction. In case any transaction failed in this series Saga will execute a series of fallback actions to undo the impact of all previous transactions. There are two approaches to implementing the Saga pattern. Choreography - The micro-service is responsible for emitting events eventually of its local transaction. The published event will trigger the execution of local transactions in microservices subscribed to the event. Also in this approach micro-service is responsible for handling the errors. Orchestration - A central orchestrator(a stateful coordinator) will trigger the local transactions in services and will maintain the global transaction status including handling errors. Now that we have a basic understanding of Saga pattern, we will discuss how to implement Saga pattern, defining an example for both approaches using Google Cloud Serverless model. The real world example Letâ€™s consider a train ticket booking system. The workflow consists of, Send a seat reservation request Check for available transits in the database and proceed with seat booking. Hold the number of seats until payment is processed. Process the payment. Confirm the seat booking. Confirm the reservation and notify the customer. However if the system encountered any error while running a local transaction, the fallback sequence should be executed to undo all the changes happening in the global transaction to keep the ACID properties. Preparing the development environment (Please note that we wonâ€™t be using a real payment gateway or a notification service, beacause the main purpose of this article is to demonstrate how to use severless model for Saga.) To implement the solution we will be using Google Cloud serverless services, MongoDb and Javascript. Before we begin we must have, A billing enabled Google Cloud project Prior knowledge in Google Cloud Services Python, NodeJs, GCloud cli tools installed in your system(If you are using Windows, WSL might come in handy) Google Cloud CLI/Cloud console You can use both CLI tools or web console to create and modify services. In this article we will be mostly using CLI tools. Please follow https://cloud.google.com/sdk/docs/install to install the Google Cloud SDK. And once you installed the SDK run gcloud init command and follow instructions to configure credentials. Building the Cloud functions project structure To build the project structure and functions, we will be using gostep, a pythonic CLI tool that I created previously to manage implementations when there are a lot of cloud functions. To use gostep you need to have Subversion CLI, Python version 3 and Pip package manager installed(Setup a virtual environment of your own preference). When you are ready, run the command, pip install gostep. For more information please refer, http://lahirus.com/gostep-intro. Also please make sure that you have enabled Cloud build APIs(https://console.cloud.google.com/apis/library/cloudbuild.googleapis.com). Using gostep, letâ€™s first create a Cloud Functions project. 1 2 3 mkdir SagaChoreography &amp;&amp; cd SagaChoreography gostep auth init reservationsservice # Creates a service account credentials file gostep base init reservations location asia-east2 version &quot;0.1.0&quot; # Creates gostep project metadata files and directory structure. Now we can have the project base. Letâ€™s move ahead with implementing local transactions and services. Choreography based solution For the demonstration we will be using, Pub/Sub for event sharing Firestore to store event data MongoDb as the transits service database Transits service This micro-service is responsible for CRUD operations on train entities. 1 2 3 4 5 6 7 8 9 10 11 12 13 // Transit document schema { transitId: string, trainName: string, start: string, destination: string, day: string, departure: number, arrival: number, availableSeats: number, lockedSeats: number, totalSeats: number } As the database, we will be using MongoDB Atlas pay as you go service in the GCP marketplace After configuring the MongoDb instance, letâ€™s create the transits function. 1 gostep service init transits version &quot;0.1.0&quot; env nodejs This will create a boilerplate NodeJs cloud function in {PROJECT_ROOT}/src/transits and it can be executed as a http request after the deployment. Now letâ€™s include the dependencies. 1 2 cd src/transits npm install --save mongodb After creating the transits database and the collection, we can add MongoDb connection URI and collection name in the src/trains/functions.json as an environment variable. 1 2 3 4 &quot;environmentVariables&quot;: { &quot;DB_URI&quot;: &quot;mongodb+srv://&lt;username&gt;:&lt;password&gt;@&lt;your-cluster-url&gt;/&lt;dbname&gt;&quot;, &quot;COLLECTION&quot;: &quot;Transits&quot; }, First letâ€™s use these environment variables and create a function to connect to the database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { MongoClient } from &quot;mongodb&quot;; const DB_URI = process.env.DB_URI || &quot;&lt;Default DB con URI&gt;&quot;; const dbClient = new MongoClient(DB_URI); const initDbClientConnection = async () =&gt; { try { await dbClient.connect(); } catch(e) { console.error(e); throw new Error(&quot;Database failed to connect!&quot;); } }; And now letâ€™s write 2 functions to find transits documents and save/update documents. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 const COLLECTION = process.env.COLLECTION || &quot;Transits&quot;; const query = async (queries) =&gt; { try { await initDbClientConnection(); const transits = dbClient.db().collection(COLLECTION); return await transits.find(queries).toArray(); } catch (e) { console.error(e); throw new Error(&quot;Failed to query transits!&quot;) } finally { await dbClient.close(); } } const save = async(transitId, patches) =&gt; { try { await initDbClientConnection(); const transits = dbClient.db().collection(COLLECTION); const targetData = { &quot;$set&quot;: patches }; await transits.updateOne({ transitId: transitId }, targetData, { upsert: true }); } catch(e) { console.error(e); throw new Error(&quot;Failed to update transits!&quot;); } finally { await dbClient.close(); } } In the main function we map GET and PUT https methods to above functions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 export const main = async (req, res) =&gt; { if(req.method === &quot;GET&quot;) { res.json(await query(req.query)); } else if(req.method === &quot;PUT&quot;) { const transitId = req.query[&quot;transitId&quot;]; if(!transitId) { res.status(400).send({ &quot;error&quot;: &quot;Invalid parameters!&quot; }) } await save(transitId, req.body); res.status(201).send(); } else { res.status(400).json({ &quot;error&quot;: &quot;Invalid request&quot; }); } } Great! Now we have our transits service. We can deploy it by running below command in the project root, 1 gostep deploy diff After the deployment, transits service can be executed using http requests. But the endpoint is not available for the public. To test it locally, use the bearer token which you can obtain using the Gcloud cli. 1 gcloud auth print-identity-token Reservations service Next, we are going to implement the entrypoint of the global transaction. Like before, letâ€™s bootstrap a cloud function again. Run, 1 gostep service init reservations version &quot;0.1.0&quot; env nodejs Now we have our boilerplate code in {PROJECT_ROOT}/src/reservations. Considering this scenario the reservations function is responsible for, Get the user request via a HTTP request. Call transits service and find out if there is any transit avaialable. If a transit is avialable publish an message to the relavent topic. Save the event data with itâ€™s status as â€˜IN_PROGRESâ€™, to update later. We are going to keep the event data stored in a database. So that we can keep the status of the particular event to use later. For that purpose we use Google Cloud firestore(data store in native mode), which is a serverless easy to use document database. To enable Firestore run, 1 gcloud firestore databases create --region=asia-southeast1 After that letâ€™s install the dependencies. In the function root({PROJECT_ROOT}/src/resrevations) run, 1 npm install --save &quot;@google-cloud/firestore&quot; &quot;@google-cloud/pubsub&quot; Letâ€™s assume below payload as the request JSON. 1 2 3 4 5 6 7 { &quot;day&quot;: &quot;Monday&quot;, &quot;start&quot;: &quot;Colombo&quot;, &quot;destination&quot;: &quot;Ragama&quot;, &quot;numberOfSeats&quot;: 10, &quot;userId&quot;: &quot;xyz@gmail.com&quot; } Once the user made his request we have to obtain the available transits for the requested day, start position and destination of the transit. To do that we will using a HTTP request to the transits service we implemeted before. Since the transits APIs are not publically available we have to use the google-auth-library to authorize requests from other services(See more). There is no need to add the auth library as a dependecy since it is an already included library in the cloud function runtime. First letâ€™s add an environment variable for the transits API endpoint in {PROJECT_ROOT}/src/transits/function.json. 1 2 3 &quot;environmentVariables&quot;: { &quot;TRANSITS_API&quot;: &quot;{HOST_ADDRESS}/transits&quot; } After that letâ€™s authorize our request to fetch available transits. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { GoogleAuth } from &quot;google-auth-library&quot;; const TRANSITS_API = process.env.TRANSITS_API || &quot;{DEFAULT_TRANSITS_HOST_ADDRESS}/transits&quot;; export const getAvailableTransits = async (numberOfSeats, day, destination, start) =&gt; { try{ // Create an authorized client to invoke restricted Transits API. const auth = new GoogleAuth(); const transitsApiClient = await auth.getIdTokenClient(TRANSITS_API); const result = await transitsApiClient.request({ url: `${TRANSITS_API}?day=${day}&amp;destination=${destination}&amp;start=${start}`, method: &quot;GET&quot; }); return result.data.filter(element =&gt; element[&quot;availableSeats&quot;] &gt;= numberOfSeats); } catch(e) { console.error(e); } }; Based on the result of the API request, we proceed further. Letâ€™s assume that we got a list of available transits and we selected the topmost transit. Now we will be saving the event data in firestore, with a unique Id(a generated UUID as correlationId) as the global transation Id to identify the local transactions group and the status of the current event. It will aid to identify the local transaction for later references. Same as before we can add the firestore collection name(reffered as kind in firestore) of the event as an environment varibale in {PROJECT_ROOT}/src/transits/function.json. 1 2 3 &quot;environmentVariables&quot;: { &quot;EVENT_DATA_COLLECTION&quot;: &quot;reservations&quot; } Now we can write our function to save event data in firestore. Please note that you donâ€™t have to include configurations to authorize the connection to the firestore since the cloud function runtime has the authorized access to the firestore in the same project. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import Firestore from &quot;@google-cloud/firestore&quot;; const EVENT_DATA_COLLECTION = process.env.EVENT_DATA_COLLECTION || &quot;reservations&quot;; export const saveEvent = async (id, eventData) =&gt; { try { const firestore = new Firestore(); const docRef = firestore.collection(EVENT_DATA_COLLECTION).doc(id); await docRef.set(eventData, { merge: true }); const result = await docRef.get() return result.exists? result.data(): {}; // return the updated doc for later references } catch(e) { console.error(e); throw new Error(&quot;Error saving event data!&quot;); } }; And since we have assumed that we have an available transit, we are going to publish a message to a pubsub topic to trigger the next event, bookings. First letâ€™s create a topic for this purpose. 1 gcloud pubsub topics create reservations.bookings And please copy the output of that command and keep it saved, we are going to need it later. Same as before letâ€™s have another environment varible for the topic name and wirte the function to publish the message. In the message we include correlationId, numberOfSeats, transitId and userId. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { PubSub } from &quot;@google-cloud/pubsub&quot;; const BOOKINGS_TOPIC = process.env.BOOKINGS_TOPIC || &quot;reservations.bookings&quot;; export const publishMessage = async (topic, message) =&gt; { try { const pubsubClient = new PubSub(); const dataBuffer = Buffer.from(JSON.stringify(message)); return await pubsubClient.topic(topic) .publishMessage({ data: dataBuffer }); } catch (e) { console.error(e); throw new Error(`Error publishing message to ${topic}!`); } } Now we have all helper functions and we can write the logic in the main funtion. Once the function is complted to deploy run, 1 gostep deploy diff Bookings service The bookings function is responsible for hold the requested number of seats in selected transit until the global transaction is finished. The acting trigger of the function will be the reservations.bookings pubsub topic we create during the previous step. Once this service successfully locked the request number of seats it will publish a message to the relevenat pubsub topic to trigger the payments function. Letâ€™s start. To initialize the function run, 1 gostep service init bookings version &quot;0.1.0&quot; env nodejs trigger pubsub Now we have bootstrapped our cloud function in {PROJECT_ROOT/src/bookings. Letâ€™s tell the funtion that it will triggered by the reservations.bookings topic. For that we can include the resource value we copied from the previous topic creation in the {PROJECT_ROOT/src/bookings/function.json. 1 2 3 4 &quot;eventTrigger&quot;: { &quot;eventType&quot;: &quot;providers/cloud.pubsub/eventTypes/topic.publish&quot;, &quot;resource&quot;: &quot;projects/{GCLOUD_PROJECT_ID}/topics/reservations.bookings&quot; } Same as the reservations function, we need to save the local transactionâ€™s event data with the correlationId and the status as IN_PROGRESS for later references. Also we can use same functions from the previous service to authorize requests to transits service and to publish the message to the next topic. What we can do is update the transit document to lock the requested number of seats. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import { GoogleAuth } from &quot;google-auth-library&quot;; const TRANSITS_API = process.env.TRANSITS_API || &quot;{TRANSITS_API_HOST}/transits&quot;; export const getTransitsById = async (transitId, client) =&gt; { try { const result = await client.request({ method: &#39;GET&#39;, url: `${TRANSITS_API}?transitId=${transitId}` }); return result.length &gt; 0? result[0]: {}; } catch (e) { console.error(e); throw new Error(`Error fetching transit data: ${transitId}`); } }; export const updateTransitsById = async (id, newData, client) =&gt; { try{ return await client.request({ method: &quot;PUT&quot;, url: `${TRANSITS_API}?transitId=${id}`, body: newData }); } catch(e) { console.error(e); } }; export const main = async (eventData) =&gt; { const transactionData = JSON.parse(atob(eventData.data)); // Extract data from pubsub message const correlationId = transactionData[&quot;correlationId&quot;]; const numberOfSeats = Number(transactionData[&quot;numberOfSeats&quot;]); const transitId = transactionData[&quot;transitId&quot;]; const userId = transactionData[&quot;userId&quot;]; const auth = new GoogleAuth(); const transitsApiClient = await auth.getIdTokenClient(TRANSITS_API); const transit = await getTransitsById(transitId, transitsApiClient); await updateTransitsById(transitId, { &quot;lockedSeats&quot;: transit[&quot;lockedSeats&quot;] + numberOfSeats, &quot;availableSeats&quot;: transit[&quot;availableSeats&quot;] - numberOfSeats }, transitsApiClient); } And like before we will be creating the next pubsub topic to publish the message from bookings. 1 gcloud pubsub topics create reservations.payments After a successful seat locking, we will be publishing a message with correlationId, numberOfClients and userId. Once the function has been completed we can deploy it using, 1 gostep deploy diff Great! Now we have covered common functionalities, Consume HTTP requests Function to function direct communication(via HTTP) Read and update event data in firestore Publishing and subscribing to Pubsub topics This is more than enough for us to implement next services. Therefor afterwards, I will be explaining the functionâ€™s role only. Payments service The payments service will consume the message from reservations.payments and publish a message to reservations.bookingCompletions or reservations.bookingCancelletions accordingly for a successful payment or for a failed payment. Booking completions service The booking completions will be consuming the messages from reservations.bookingCompletions topic, will be update the transit as the seat booking is completed and after that will update previously saved booking eventâ€™s status from IN_PROGRESS to COMPLETED for the relevant correlationId. Then the service will publish an message to the reservations.reservationCompletions topic. Booking cancellations service In the event of a payment failure, after consuming the message from the topic reservations.bookingCancelletions this function will rollback the locked seats in the relevant transit, will update booking eventâ€™s status from IN_PROGRESS to FAILED for the relevant correlationId and will pass the correlationId to the reservations.reservationCancellations topic. Reservation completions service As the final step of a completed series of events the reservation completions service will consume the correlation id for the transaction from reservations.reservationCompletions and will update previously saved reservations eventâ€™s status from IN_PROGRESS to COMPLETED. After that a message will be published to the reservations.notifications topic to send the successful transaction notifications to the customer. Reservation cancellations service Consuming the message from reservations.reservationCancellations this function will update previously saved reservations eventâ€™s status from IN_PROGRESS to FAILED and will publish a message to the reservations.notifications topic to send the failed transaction notifications status to the customer. Securing the entrypoint After deploying all the services we can use Google API gateway to secure our reservations entrypoint of the transaction. Please refer API gatewey quickstart. ðŸ¦– Letâ€™s look into Orchestration based solution in the next article." />
<meta property="og:description" content="Gostep: ðŸ‘‰ Guide Materials: ðŸ‘‰ Complete source code During the past few years, the microservices architecture(MSA) and serverless model have gained a lot of popularity in the industry. However, these technologies come with their own set of challenges. One substantial challenge is managing data in MSA due to its complexity. Considering common patterns for MSA data management we will be focusing on the Saga pattern in this article. The Saga pattern In order to manage business transactions across multiple microservices, the Saga pattern was introduced. Basically it is a series of local transactions; every transaction happens within the boundary of the micro-service, which every service will publish an event after the transaction for the next subsequent micro-service to perform the next transaction consuming the published event. This process will continue till the last transaction. In case any transaction failed in this series Saga will execute a series of fallback actions to undo the impact of all previous transactions. There are two approaches to implementing the Saga pattern. Choreography - The micro-service is responsible for emitting events eventually of its local transaction. The published event will trigger the execution of local transactions in microservices subscribed to the event. Also in this approach micro-service is responsible for handling the errors. Orchestration - A central orchestrator(a stateful coordinator) will trigger the local transactions in services and will maintain the global transaction status including handling errors. Now that we have a basic understanding of Saga pattern, we will discuss how to implement Saga pattern, defining an example for both approaches using Google Cloud Serverless model. The real world example Letâ€™s consider a train ticket booking system. The workflow consists of, Send a seat reservation request Check for available transits in the database and proceed with seat booking. Hold the number of seats until payment is processed. Process the payment. Confirm the seat booking. Confirm the reservation and notify the customer. However if the system encountered any error while running a local transaction, the fallback sequence should be executed to undo all the changes happening in the global transaction to keep the ACID properties. Preparing the development environment (Please note that we wonâ€™t be using a real payment gateway or a notification service, beacause the main purpose of this article is to demonstrate how to use severless model for Saga.) To implement the solution we will be using Google Cloud serverless services, MongoDb and Javascript. Before we begin we must have, A billing enabled Google Cloud project Prior knowledge in Google Cloud Services Python, NodeJs, GCloud cli tools installed in your system(If you are using Windows, WSL might come in handy) Google Cloud CLI/Cloud console You can use both CLI tools or web console to create and modify services. In this article we will be mostly using CLI tools. Please follow https://cloud.google.com/sdk/docs/install to install the Google Cloud SDK. And once you installed the SDK run gcloud init command and follow instructions to configure credentials. Building the Cloud functions project structure To build the project structure and functions, we will be using gostep, a pythonic CLI tool that I created previously to manage implementations when there are a lot of cloud functions. To use gostep you need to have Subversion CLI, Python version 3 and Pip package manager installed(Setup a virtual environment of your own preference). When you are ready, run the command, pip install gostep. For more information please refer, http://lahirus.com/gostep-intro. Also please make sure that you have enabled Cloud build APIs(https://console.cloud.google.com/apis/library/cloudbuild.googleapis.com). Using gostep, letâ€™s first create a Cloud Functions project. 1 2 3 mkdir SagaChoreography &amp;&amp; cd SagaChoreography gostep auth init reservationsservice # Creates a service account credentials file gostep base init reservations location asia-east2 version &quot;0.1.0&quot; # Creates gostep project metadata files and directory structure. Now we can have the project base. Letâ€™s move ahead with implementing local transactions and services. Choreography based solution For the demonstration we will be using, Pub/Sub for event sharing Firestore to store event data MongoDb as the transits service database Transits service This micro-service is responsible for CRUD operations on train entities. 1 2 3 4 5 6 7 8 9 10 11 12 13 // Transit document schema { transitId: string, trainName: string, start: string, destination: string, day: string, departure: number, arrival: number, availableSeats: number, lockedSeats: number, totalSeats: number } As the database, we will be using MongoDB Atlas pay as you go service in the GCP marketplace After configuring the MongoDb instance, letâ€™s create the transits function. 1 gostep service init transits version &quot;0.1.0&quot; env nodejs This will create a boilerplate NodeJs cloud function in {PROJECT_ROOT}/src/transits and it can be executed as a http request after the deployment. Now letâ€™s include the dependencies. 1 2 cd src/transits npm install --save mongodb After creating the transits database and the collection, we can add MongoDb connection URI and collection name in the src/trains/functions.json as an environment variable. 1 2 3 4 &quot;environmentVariables&quot;: { &quot;DB_URI&quot;: &quot;mongodb+srv://&lt;username&gt;:&lt;password&gt;@&lt;your-cluster-url&gt;/&lt;dbname&gt;&quot;, &quot;COLLECTION&quot;: &quot;Transits&quot; }, First letâ€™s use these environment variables and create a function to connect to the database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { MongoClient } from &quot;mongodb&quot;; const DB_URI = process.env.DB_URI || &quot;&lt;Default DB con URI&gt;&quot;; const dbClient = new MongoClient(DB_URI); const initDbClientConnection = async () =&gt; { try { await dbClient.connect(); } catch(e) { console.error(e); throw new Error(&quot;Database failed to connect!&quot;); } }; And now letâ€™s write 2 functions to find transits documents and save/update documents. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 const COLLECTION = process.env.COLLECTION || &quot;Transits&quot;; const query = async (queries) =&gt; { try { await initDbClientConnection(); const transits = dbClient.db().collection(COLLECTION); return await transits.find(queries).toArray(); } catch (e) { console.error(e); throw new Error(&quot;Failed to query transits!&quot;) } finally { await dbClient.close(); } } const save = async(transitId, patches) =&gt; { try { await initDbClientConnection(); const transits = dbClient.db().collection(COLLECTION); const targetData = { &quot;$set&quot;: patches }; await transits.updateOne({ transitId: transitId }, targetData, { upsert: true }); } catch(e) { console.error(e); throw new Error(&quot;Failed to update transits!&quot;); } finally { await dbClient.close(); } } In the main function we map GET and PUT https methods to above functions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 export const main = async (req, res) =&gt; { if(req.method === &quot;GET&quot;) { res.json(await query(req.query)); } else if(req.method === &quot;PUT&quot;) { const transitId = req.query[&quot;transitId&quot;]; if(!transitId) { res.status(400).send({ &quot;error&quot;: &quot;Invalid parameters!&quot; }) } await save(transitId, req.body); res.status(201).send(); } else { res.status(400).json({ &quot;error&quot;: &quot;Invalid request&quot; }); } } Great! Now we have our transits service. We can deploy it by running below command in the project root, 1 gostep deploy diff After the deployment, transits service can be executed using http requests. But the endpoint is not available for the public. To test it locally, use the bearer token which you can obtain using the Gcloud cli. 1 gcloud auth print-identity-token Reservations service Next, we are going to implement the entrypoint of the global transaction. Like before, letâ€™s bootstrap a cloud function again. Run, 1 gostep service init reservations version &quot;0.1.0&quot; env nodejs Now we have our boilerplate code in {PROJECT_ROOT}/src/reservations. Considering this scenario the reservations function is responsible for, Get the user request via a HTTP request. Call transits service and find out if there is any transit avaialable. If a transit is avialable publish an message to the relavent topic. Save the event data with itâ€™s status as â€˜IN_PROGRESâ€™, to update later. We are going to keep the event data stored in a database. So that we can keep the status of the particular event to use later. For that purpose we use Google Cloud firestore(data store in native mode), which is a serverless easy to use document database. To enable Firestore run, 1 gcloud firestore databases create --region=asia-southeast1 After that letâ€™s install the dependencies. In the function root({PROJECT_ROOT}/src/resrevations) run, 1 npm install --save &quot;@google-cloud/firestore&quot; &quot;@google-cloud/pubsub&quot; Letâ€™s assume below payload as the request JSON. 1 2 3 4 5 6 7 { &quot;day&quot;: &quot;Monday&quot;, &quot;start&quot;: &quot;Colombo&quot;, &quot;destination&quot;: &quot;Ragama&quot;, &quot;numberOfSeats&quot;: 10, &quot;userId&quot;: &quot;xyz@gmail.com&quot; } Once the user made his request we have to obtain the available transits for the requested day, start position and destination of the transit. To do that we will using a HTTP request to the transits service we implemeted before. Since the transits APIs are not publically available we have to use the google-auth-library to authorize requests from other services(See more). There is no need to add the auth library as a dependecy since it is an already included library in the cloud function runtime. First letâ€™s add an environment variable for the transits API endpoint in {PROJECT_ROOT}/src/transits/function.json. 1 2 3 &quot;environmentVariables&quot;: { &quot;TRANSITS_API&quot;: &quot;{HOST_ADDRESS}/transits&quot; } After that letâ€™s authorize our request to fetch available transits. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { GoogleAuth } from &quot;google-auth-library&quot;; const TRANSITS_API = process.env.TRANSITS_API || &quot;{DEFAULT_TRANSITS_HOST_ADDRESS}/transits&quot;; export const getAvailableTransits = async (numberOfSeats, day, destination, start) =&gt; { try{ // Create an authorized client to invoke restricted Transits API. const auth = new GoogleAuth(); const transitsApiClient = await auth.getIdTokenClient(TRANSITS_API); const result = await transitsApiClient.request({ url: `${TRANSITS_API}?day=${day}&amp;destination=${destination}&amp;start=${start}`, method: &quot;GET&quot; }); return result.data.filter(element =&gt; element[&quot;availableSeats&quot;] &gt;= numberOfSeats); } catch(e) { console.error(e); } }; Based on the result of the API request, we proceed further. Letâ€™s assume that we got a list of available transits and we selected the topmost transit. Now we will be saving the event data in firestore, with a unique Id(a generated UUID as correlationId) as the global transation Id to identify the local transactions group and the status of the current event. It will aid to identify the local transaction for later references. Same as before we can add the firestore collection name(reffered as kind in firestore) of the event as an environment varibale in {PROJECT_ROOT}/src/transits/function.json. 1 2 3 &quot;environmentVariables&quot;: { &quot;EVENT_DATA_COLLECTION&quot;: &quot;reservations&quot; } Now we can write our function to save event data in firestore. Please note that you donâ€™t have to include configurations to authorize the connection to the firestore since the cloud function runtime has the authorized access to the firestore in the same project. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import Firestore from &quot;@google-cloud/firestore&quot;; const EVENT_DATA_COLLECTION = process.env.EVENT_DATA_COLLECTION || &quot;reservations&quot;; export const saveEvent = async (id, eventData) =&gt; { try { const firestore = new Firestore(); const docRef = firestore.collection(EVENT_DATA_COLLECTION).doc(id); await docRef.set(eventData, { merge: true }); const result = await docRef.get() return result.exists? result.data(): {}; // return the updated doc for later references } catch(e) { console.error(e); throw new Error(&quot;Error saving event data!&quot;); } }; And since we have assumed that we have an available transit, we are going to publish a message to a pubsub topic to trigger the next event, bookings. First letâ€™s create a topic for this purpose. 1 gcloud pubsub topics create reservations.bookings And please copy the output of that command and keep it saved, we are going to need it later. Same as before letâ€™s have another environment varible for the topic name and wirte the function to publish the message. In the message we include correlationId, numberOfSeats, transitId and userId. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { PubSub } from &quot;@google-cloud/pubsub&quot;; const BOOKINGS_TOPIC = process.env.BOOKINGS_TOPIC || &quot;reservations.bookings&quot;; export const publishMessage = async (topic, message) =&gt; { try { const pubsubClient = new PubSub(); const dataBuffer = Buffer.from(JSON.stringify(message)); return await pubsubClient.topic(topic) .publishMessage({ data: dataBuffer }); } catch (e) { console.error(e); throw new Error(`Error publishing message to ${topic}!`); } } Now we have all helper functions and we can write the logic in the main funtion. Once the function is complted to deploy run, 1 gostep deploy diff Bookings service The bookings function is responsible for hold the requested number of seats in selected transit until the global transaction is finished. The acting trigger of the function will be the reservations.bookings pubsub topic we create during the previous step. Once this service successfully locked the request number of seats it will publish a message to the relevenat pubsub topic to trigger the payments function. Letâ€™s start. To initialize the function run, 1 gostep service init bookings version &quot;0.1.0&quot; env nodejs trigger pubsub Now we have bootstrapped our cloud function in {PROJECT_ROOT/src/bookings. Letâ€™s tell the funtion that it will triggered by the reservations.bookings topic. For that we can include the resource value we copied from the previous topic creation in the {PROJECT_ROOT/src/bookings/function.json. 1 2 3 4 &quot;eventTrigger&quot;: { &quot;eventType&quot;: &quot;providers/cloud.pubsub/eventTypes/topic.publish&quot;, &quot;resource&quot;: &quot;projects/{GCLOUD_PROJECT_ID}/topics/reservations.bookings&quot; } Same as the reservations function, we need to save the local transactionâ€™s event data with the correlationId and the status as IN_PROGRESS for later references. Also we can use same functions from the previous service to authorize requests to transits service and to publish the message to the next topic. What we can do is update the transit document to lock the requested number of seats. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import { GoogleAuth } from &quot;google-auth-library&quot;; const TRANSITS_API = process.env.TRANSITS_API || &quot;{TRANSITS_API_HOST}/transits&quot;; export const getTransitsById = async (transitId, client) =&gt; { try { const result = await client.request({ method: &#39;GET&#39;, url: `${TRANSITS_API}?transitId=${transitId}` }); return result.length &gt; 0? result[0]: {}; } catch (e) { console.error(e); throw new Error(`Error fetching transit data: ${transitId}`); } }; export const updateTransitsById = async (id, newData, client) =&gt; { try{ return await client.request({ method: &quot;PUT&quot;, url: `${TRANSITS_API}?transitId=${id}`, body: newData }); } catch(e) { console.error(e); } }; export const main = async (eventData) =&gt; { const transactionData = JSON.parse(atob(eventData.data)); // Extract data from pubsub message const correlationId = transactionData[&quot;correlationId&quot;]; const numberOfSeats = Number(transactionData[&quot;numberOfSeats&quot;]); const transitId = transactionData[&quot;transitId&quot;]; const userId = transactionData[&quot;userId&quot;]; const auth = new GoogleAuth(); const transitsApiClient = await auth.getIdTokenClient(TRANSITS_API); const transit = await getTransitsById(transitId, transitsApiClient); await updateTransitsById(transitId, { &quot;lockedSeats&quot;: transit[&quot;lockedSeats&quot;] + numberOfSeats, &quot;availableSeats&quot;: transit[&quot;availableSeats&quot;] - numberOfSeats }, transitsApiClient); } And like before we will be creating the next pubsub topic to publish the message from bookings. 1 gcloud pubsub topics create reservations.payments After a successful seat locking, we will be publishing a message with correlationId, numberOfClients and userId. Once the function has been completed we can deploy it using, 1 gostep deploy diff Great! Now we have covered common functionalities, Consume HTTP requests Function to function direct communication(via HTTP) Read and update event data in firestore Publishing and subscribing to Pubsub topics This is more than enough for us to implement next services. Therefor afterwards, I will be explaining the functionâ€™s role only. Payments service The payments service will consume the message from reservations.payments and publish a message to reservations.bookingCompletions or reservations.bookingCancelletions accordingly for a successful payment or for a failed payment. Booking completions service The booking completions will be consuming the messages from reservations.bookingCompletions topic, will be update the transit as the seat booking is completed and after that will update previously saved booking eventâ€™s status from IN_PROGRESS to COMPLETED for the relevant correlationId. Then the service will publish an message to the reservations.reservationCompletions topic. Booking cancellations service In the event of a payment failure, after consuming the message from the topic reservations.bookingCancelletions this function will rollback the locked seats in the relevant transit, will update booking eventâ€™s status from IN_PROGRESS to FAILED for the relevant correlationId and will pass the correlationId to the reservations.reservationCancellations topic. Reservation completions service As the final step of a completed series of events the reservation completions service will consume the correlation id for the transaction from reservations.reservationCompletions and will update previously saved reservations eventâ€™s status from IN_PROGRESS to COMPLETED. After that a message will be published to the reservations.notifications topic to send the successful transaction notifications to the customer. Reservation cancellations service Consuming the message from reservations.reservationCancellations this function will update previously saved reservations eventâ€™s status from IN_PROGRESS to FAILED and will publish a message to the reservations.notifications topic to send the failed transaction notifications status to the customer. Securing the entrypoint After deploying all the services we can use Google API gateway to secure our reservations entrypoint of the transaction. Please refer API gatewey quickstart. ðŸ¦– Letâ€™s look into Orchestration based solution in the next article." />
<link rel="canonical" href="/posts/saga-gcp-choreography/" />
<meta property="og:url" content="/posts/saga-gcp-choreography/" />
<meta property="og:site_name" content="Lahiruâ€™s dev journal" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-11-20T00:00:00+05:30" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Saga Pattern with serverless model on Google Cloud Platform - Part 1" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Lahiru Pathirage","url":"https://github.com/lpsandaruwan/"},"dateModified":"2023-11-03T21:56:02+05:30","datePublished":"2022-11-20T00:00:00+05:30","description":"Gostep: ðŸ‘‰ Guide Materials: ðŸ‘‰ Complete source code During the past few years, the microservices architecture(MSA) and serverless model have gained a lot of popularity in the industry. However, these technologies come with their own set of challenges. One substantial challenge is managing data in MSA due to its complexity. Considering common patterns for MSA data management we will be focusing on the Saga pattern in this article. The Saga pattern In order to manage business transactions across multiple microservices, the Saga pattern was introduced. Basically it is a series of local transactions; every transaction happens within the boundary of the micro-service, which every service will publish an event after the transaction for the next subsequent micro-service to perform the next transaction consuming the published event. This process will continue till the last transaction. In case any transaction failed in this series Saga will execute a series of fallback actions to undo the impact of all previous transactions. There are two approaches to implementing the Saga pattern. Choreography - The micro-service is responsible for emitting events eventually of its local transaction. The published event will trigger the execution of local transactions in microservices subscribed to the event. Also in this approach micro-service is responsible for handling the errors. Orchestration - A central orchestrator(a stateful coordinator) will trigger the local transactions in services and will maintain the global transaction status including handling errors. Now that we have a basic understanding of Saga pattern, we will discuss how to implement Saga pattern, defining an example for both approaches using Google Cloud Serverless model. The real world example Letâ€™s consider a train ticket booking system. The workflow consists of, Send a seat reservation request Check for available transits in the database and proceed with seat booking. Hold the number of seats until payment is processed. Process the payment. Confirm the seat booking. Confirm the reservation and notify the customer. However if the system encountered any error while running a local transaction, the fallback sequence should be executed to undo all the changes happening in the global transaction to keep the ACID properties. Preparing the development environment (Please note that we wonâ€™t be using a real payment gateway or a notification service, beacause the main purpose of this article is to demonstrate how to use severless model for Saga.) To implement the solution we will be using Google Cloud serverless services, MongoDb and Javascript. Before we begin we must have, A billing enabled Google Cloud project Prior knowledge in Google Cloud Services Python, NodeJs, GCloud cli tools installed in your system(If you are using Windows, WSL might come in handy) Google Cloud CLI/Cloud console You can use both CLI tools or web console to create and modify services. In this article we will be mostly using CLI tools. Please follow https://cloud.google.com/sdk/docs/install to install the Google Cloud SDK. And once you installed the SDK run gcloud init command and follow instructions to configure credentials. Building the Cloud functions project structure To build the project structure and functions, we will be using gostep, a pythonic CLI tool that I created previously to manage implementations when there are a lot of cloud functions. To use gostep you need to have Subversion CLI, Python version 3 and Pip package manager installed(Setup a virtual environment of your own preference). When you are ready, run the command, pip install gostep. For more information please refer, http://lahirus.com/gostep-intro. Also please make sure that you have enabled Cloud build APIs(https://console.cloud.google.com/apis/library/cloudbuild.googleapis.com). Using gostep, letâ€™s first create a Cloud Functions project. 1 2 3 mkdir SagaChoreography &amp;&amp; cd SagaChoreography gostep auth init reservationsservice # Creates a service account credentials file gostep base init reservations location asia-east2 version &quot;0.1.0&quot; # Creates gostep project metadata files and directory structure. Now we can have the project base. Letâ€™s move ahead with implementing local transactions and services. Choreography based solution For the demonstration we will be using, Pub/Sub for event sharing Firestore to store event data MongoDb as the transits service database Transits service This micro-service is responsible for CRUD operations on train entities. 1 2 3 4 5 6 7 8 9 10 11 12 13 // Transit document schema { transitId: string, trainName: string, start: string, destination: string, day: string, departure: number, arrival: number, availableSeats: number, lockedSeats: number, totalSeats: number } As the database, we will be using MongoDB Atlas pay as you go service in the GCP marketplace After configuring the MongoDb instance, letâ€™s create the transits function. 1 gostep service init transits version &quot;0.1.0&quot; env nodejs This will create a boilerplate NodeJs cloud function in {PROJECT_ROOT}/src/transits and it can be executed as a http request after the deployment. Now letâ€™s include the dependencies. 1 2 cd src/transits npm install --save mongodb After creating the transits database and the collection, we can add MongoDb connection URI and collection name in the src/trains/functions.json as an environment variable. 1 2 3 4 &quot;environmentVariables&quot;: { &quot;DB_URI&quot;: &quot;mongodb+srv://&lt;username&gt;:&lt;password&gt;@&lt;your-cluster-url&gt;/&lt;dbname&gt;&quot;, &quot;COLLECTION&quot;: &quot;Transits&quot; }, First letâ€™s use these environment variables and create a function to connect to the database. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import { MongoClient } from &quot;mongodb&quot;; const DB_URI = process.env.DB_URI || &quot;&lt;Default DB con URI&gt;&quot;; const dbClient = new MongoClient(DB_URI); const initDbClientConnection = async () =&gt; { try { await dbClient.connect(); } catch(e) { console.error(e); throw new Error(&quot;Database failed to connect!&quot;); } }; And now letâ€™s write 2 functions to find transits documents and save/update documents. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 const COLLECTION = process.env.COLLECTION || &quot;Transits&quot;; const query = async (queries) =&gt; { try { await initDbClientConnection(); const transits = dbClient.db().collection(COLLECTION); return await transits.find(queries).toArray(); } catch (e) { console.error(e); throw new Error(&quot;Failed to query transits!&quot;) } finally { await dbClient.close(); } } const save = async(transitId, patches) =&gt; { try { await initDbClientConnection(); const transits = dbClient.db().collection(COLLECTION); const targetData = { &quot;$set&quot;: patches }; await transits.updateOne({ transitId: transitId }, targetData, { upsert: true }); } catch(e) { console.error(e); throw new Error(&quot;Failed to update transits!&quot;); } finally { await dbClient.close(); } } In the main function we map GET and PUT https methods to above functions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 export const main = async (req, res) =&gt; { if(req.method === &quot;GET&quot;) { res.json(await query(req.query)); } else if(req.method === &quot;PUT&quot;) { const transitId = req.query[&quot;transitId&quot;]; if(!transitId) { res.status(400).send({ &quot;error&quot;: &quot;Invalid parameters!&quot; }) } await save(transitId, req.body); res.status(201).send(); } else { res.status(400).json({ &quot;error&quot;: &quot;Invalid request&quot; }); } } Great! Now we have our transits service. We can deploy it by running below command in the project root, 1 gostep deploy diff After the deployment, transits service can be executed using http requests. But the endpoint is not available for the public. To test it locally, use the bearer token which you can obtain using the Gcloud cli. 1 gcloud auth print-identity-token Reservations service Next, we are going to implement the entrypoint of the global transaction. Like before, letâ€™s bootstrap a cloud function again. Run, 1 gostep service init reservations version &quot;0.1.0&quot; env nodejs Now we have our boilerplate code in {PROJECT_ROOT}/src/reservations. Considering this scenario the reservations function is responsible for, Get the user request via a HTTP request. Call transits service and find out if there is any transit avaialable. If a transit is avialable publish an message to the relavent topic. Save the event data with itâ€™s status as â€˜IN_PROGRESâ€™, to update later. We are going to keep the event data stored in a database. So that we can keep the status of the particular event to use later. For that purpose we use Google Cloud firestore(data store in native mode), which is a serverless easy to use document database. To enable Firestore run, 1 gcloud firestore databases create --region=asia-southeast1 After that letâ€™s install the dependencies. In the function root({PROJECT_ROOT}/src/resrevations) run, 1 npm install --save &quot;@google-cloud/firestore&quot; &quot;@google-cloud/pubsub&quot; Letâ€™s assume below payload as the request JSON. 1 2 3 4 5 6 7 { &quot;day&quot;: &quot;Monday&quot;, &quot;start&quot;: &quot;Colombo&quot;, &quot;destination&quot;: &quot;Ragama&quot;, &quot;numberOfSeats&quot;: 10, &quot;userId&quot;: &quot;xyz@gmail.com&quot; } Once the user made his request we have to obtain the available transits for the requested day, start position and destination of the transit. To do that we will using a HTTP request to the transits service we implemeted before. Since the transits APIs are not publically available we have to use the google-auth-library to authorize requests from other services(See more). There is no need to add the auth library as a dependecy since it is an already included library in the cloud function runtime. First letâ€™s add an environment variable for the transits API endpoint in {PROJECT_ROOT}/src/transits/function.json. 1 2 3 &quot;environmentVariables&quot;: { &quot;TRANSITS_API&quot;: &quot;{HOST_ADDRESS}/transits&quot; } After that letâ€™s authorize our request to fetch available transits. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import { GoogleAuth } from &quot;google-auth-library&quot;; const TRANSITS_API = process.env.TRANSITS_API || &quot;{DEFAULT_TRANSITS_HOST_ADDRESS}/transits&quot;; export const getAvailableTransits = async (numberOfSeats, day, destination, start) =&gt; { try{ // Create an authorized client to invoke restricted Transits API. const auth = new GoogleAuth(); const transitsApiClient = await auth.getIdTokenClient(TRANSITS_API); const result = await transitsApiClient.request({ url: `${TRANSITS_API}?day=${day}&amp;destination=${destination}&amp;start=${start}`, method: &quot;GET&quot; }); return result.data.filter(element =&gt; element[&quot;availableSeats&quot;] &gt;= numberOfSeats); } catch(e) { console.error(e); } }; Based on the result of the API request, we proceed further. Letâ€™s assume that we got a list of available transits and we selected the topmost transit. Now we will be saving the event data in firestore, with a unique Id(a generated UUID as correlationId) as the global transation Id to identify the local transactions group and the status of the current event. It will aid to identify the local transaction for later references. Same as before we can add the firestore collection name(reffered as kind in firestore) of the event as an environment varibale in {PROJECT_ROOT}/src/transits/function.json. 1 2 3 &quot;environmentVariables&quot;: { &quot;EVENT_DATA_COLLECTION&quot;: &quot;reservations&quot; } Now we can write our function to save event data in firestore. Please note that you donâ€™t have to include configurations to authorize the connection to the firestore since the cloud function runtime has the authorized access to the firestore in the same project. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import Firestore from &quot;@google-cloud/firestore&quot;; const EVENT_DATA_COLLECTION = process.env.EVENT_DATA_COLLECTION || &quot;reservations&quot;; export const saveEvent = async (id, eventData) =&gt; { try { const firestore = new Firestore(); const docRef = firestore.collection(EVENT_DATA_COLLECTION).doc(id); await docRef.set(eventData, { merge: true }); const result = await docRef.get() return result.exists? result.data(): {}; // return the updated doc for later references } catch(e) { console.error(e); throw new Error(&quot;Error saving event data!&quot;); } }; And since we have assumed that we have an available transit, we are going to publish a message to a pubsub topic to trigger the next event, bookings. First letâ€™s create a topic for this purpose. 1 gcloud pubsub topics create reservations.bookings And please copy the output of that command and keep it saved, we are going to need it later. Same as before letâ€™s have another environment varible for the topic name and wirte the function to publish the message. In the message we include correlationId, numberOfSeats, transitId and userId. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import { PubSub } from &quot;@google-cloud/pubsub&quot;; const BOOKINGS_TOPIC = process.env.BOOKINGS_TOPIC || &quot;reservations.bookings&quot;; export const publishMessage = async (topic, message) =&gt; { try { const pubsubClient = new PubSub(); const dataBuffer = Buffer.from(JSON.stringify(message)); return await pubsubClient.topic(topic) .publishMessage({ data: dataBuffer }); } catch (e) { console.error(e); throw new Error(`Error publishing message to ${topic}!`); } } Now we have all helper functions and we can write the logic in the main funtion. Once the function is complted to deploy run, 1 gostep deploy diff Bookings service The bookings function is responsible for hold the requested number of seats in selected transit until the global transaction is finished. The acting trigger of the function will be the reservations.bookings pubsub topic we create during the previous step. Once this service successfully locked the request number of seats it will publish a message to the relevenat pubsub topic to trigger the payments function. Letâ€™s start. To initialize the function run, 1 gostep service init bookings version &quot;0.1.0&quot; env nodejs trigger pubsub Now we have bootstrapped our cloud function in {PROJECT_ROOT/src/bookings. Letâ€™s tell the funtion that it will triggered by the reservations.bookings topic. For that we can include the resource value we copied from the previous topic creation in the {PROJECT_ROOT/src/bookings/function.json. 1 2 3 4 &quot;eventTrigger&quot;: { &quot;eventType&quot;: &quot;providers/cloud.pubsub/eventTypes/topic.publish&quot;, &quot;resource&quot;: &quot;projects/{GCLOUD_PROJECT_ID}/topics/reservations.bookings&quot; } Same as the reservations function, we need to save the local transactionâ€™s event data with the correlationId and the status as IN_PROGRESS for later references. Also we can use same functions from the previous service to authorize requests to transits service and to publish the message to the next topic. What we can do is update the transit document to lock the requested number of seats. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import { GoogleAuth } from &quot;google-auth-library&quot;; const TRANSITS_API = process.env.TRANSITS_API || &quot;{TRANSITS_API_HOST}/transits&quot;; export const getTransitsById = async (transitId, client) =&gt; { try { const result = await client.request({ method: &#39;GET&#39;, url: `${TRANSITS_API}?transitId=${transitId}` }); return result.length &gt; 0? result[0]: {}; } catch (e) { console.error(e); throw new Error(`Error fetching transit data: ${transitId}`); } }; export const updateTransitsById = async (id, newData, client) =&gt; { try{ return await client.request({ method: &quot;PUT&quot;, url: `${TRANSITS_API}?transitId=${id}`, body: newData }); } catch(e) { console.error(e); } }; export const main = async (eventData) =&gt; { const transactionData = JSON.parse(atob(eventData.data)); // Extract data from pubsub message const correlationId = transactionData[&quot;correlationId&quot;]; const numberOfSeats = Number(transactionData[&quot;numberOfSeats&quot;]); const transitId = transactionData[&quot;transitId&quot;]; const userId = transactionData[&quot;userId&quot;]; const auth = new GoogleAuth(); const transitsApiClient = await auth.getIdTokenClient(TRANSITS_API); const transit = await getTransitsById(transitId, transitsApiClient); await updateTransitsById(transitId, { &quot;lockedSeats&quot;: transit[&quot;lockedSeats&quot;] + numberOfSeats, &quot;availableSeats&quot;: transit[&quot;availableSeats&quot;] - numberOfSeats }, transitsApiClient); } And like before we will be creating the next pubsub topic to publish the message from bookings. 1 gcloud pubsub topics create reservations.payments After a successful seat locking, we will be publishing a message with correlationId, numberOfClients and userId. Once the function has been completed we can deploy it using, 1 gostep deploy diff Great! Now we have covered common functionalities, Consume HTTP requests Function to function direct communication(via HTTP) Read and update event data in firestore Publishing and subscribing to Pubsub topics This is more than enough for us to implement next services. Therefor afterwards, I will be explaining the functionâ€™s role only. Payments service The payments service will consume the message from reservations.payments and publish a message to reservations.bookingCompletions or reservations.bookingCancelletions accordingly for a successful payment or for a failed payment. Booking completions service The booking completions will be consuming the messages from reservations.bookingCompletions topic, will be update the transit as the seat booking is completed and after that will update previously saved booking eventâ€™s status from IN_PROGRESS to COMPLETED for the relevant correlationId. Then the service will publish an message to the reservations.reservationCompletions topic. Booking cancellations service In the event of a payment failure, after consuming the message from the topic reservations.bookingCancelletions this function will rollback the locked seats in the relevant transit, will update booking eventâ€™s status from IN_PROGRESS to FAILED for the relevant correlationId and will pass the correlationId to the reservations.reservationCancellations topic. Reservation completions service As the final step of a completed series of events the reservation completions service will consume the correlation id for the transaction from reservations.reservationCompletions and will update previously saved reservations eventâ€™s status from IN_PROGRESS to COMPLETED. After that a message will be published to the reservations.notifications topic to send the successful transaction notifications to the customer. Reservation cancellations service Consuming the message from reservations.reservationCancellations this function will update previously saved reservations eventâ€™s status from IN_PROGRESS to FAILED and will publish a message to the reservations.notifications topic to send the failed transaction notifications status to the customer. Securing the entrypoint After deploying all the services we can use Google API gateway to secure our reservations entrypoint of the transaction. Please refer API gatewey quickstart. ðŸ¦– Letâ€™s look into Orchestration based solution in the next article.","headline":"Saga Pattern with serverless model on Google Cloud Platform - Part 1","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/saga-gcp-choreography/"},"url":"/posts/saga-gcp-choreography/"}</script>
<!-- End Jekyll SEO tag -->

  

  <title>Saga Pattern with serverless model on Google Cloud Platform - Part 1 | Lahiru's dev journal
  </title>

  <!--
  The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps
  Generated by: https://realfavicongenerator.net/
-->



<link rel="manifest" href="/assets/img/favicons/site.webmanifest">
<link rel="shortcut icon" href="/assets/img/favicons/favicon.ico">
<meta name="apple-mobile-web-app-title" content="Lahiru's dev journal">
<meta name="application-name" content="Lahiru's dev journal">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">


  
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin>
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://cdn.jsdelivr.net" >
      <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" >
    

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap">
  

  <!-- GA -->
  

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css">

  <link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css">

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.21.2/dist/tocbot.min.css">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css">
  

  
    <!-- Manific Popup -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css">
  

  <!-- JavaScript -->

  

  <!-- A placeholder to allow defining custom metadata -->

</head>


  <body class="plasma-desktop-body">
    <!-- Desktop Background -->
    <div id="plasma-desktop">
      <div class="desktop-wallpaper">

        <!-- Desktop File Manager Area -->
        <div class="desktop-content">
          <div class="file-manager-window">
            <div class="window-titlebar">
              <div class="window-title">
                <i class="fas fa-folder"></i>
                Dolphin - Lahiru's dev journal
              </div>
            </div>
            
            <div class="file-manager-content">
              <!-- Sidebar -->
              <div class="fm-sidebar">
                <!-- The Side Bar -->

<aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end">
  <header class="profile-wrapper">
    <a href="/" id="avatar" class="rounded-circle">
      
      
      <img src="/assets/img/me.jpeg" width="112" height="112" alt="avatar" onerror="this.style.display='none'">
      
    </a>

    <h1 class="site-title">
      <a href="/">Lahiru's dev journal</a>
    </h1>
    <p class="site-subtitle fst-italic mb-0">Hey, I'm Lahiru Pathirage. I've been professionally building software since 2016, working on everything from simple tools to complex enterprise systems. One thing thatâ€™s always held true for me is that good design leads to great software. I'm deeply focused on AI agents and serverless architecture;  building systems that are intelligent, scalable, and require minimal human intervention. I'm a computer science graduate who feels at home in a terminal, loves Linux, and believes open source makes everything better.</p>
  </header>
  <!-- .profile-wrapper -->

  <nav class="flex-column flex-grow-1 w-100 ps-0">
    <ul class="nav">
      <!-- documents -->
      <li class="nav-item">
        <a href="/" class="nav-link">
          <i class="fa-fw fas fa-folder"></i>
          <span>DOCUMENTS</span>
        </a>
      </li>
      <!-- the real tabs -->
      <li class="nav-item">
        <a href="/archives/" class="nav-link">
          <i class="fa-fw fas fa-file-archive"></i>
          <span>ARK</span>
        </a>
      </li>
      
      <li class="nav-item">
        <a href="/projects/" class="nav-link">
          <i class="fa-fw fas fa-chart-area"></i>
          <span>KSYSGUARD</span>
        </a>
      </li>
    </ul>
  </nav>

  <div class="sidebar-bottom d-flex flex-wrap  align-items-center w-100">
    

    
    

    
    <a href="https://linkedin.com/in/lpsandaruwan" aria-label="linkedin"  
      target="_blank"    
      rel="noopener noreferrer" >
      <i class="fab fa-linkedin"></i>
    </a>
    
    
    

    
    <a href="https://github.com/lpsandaruwan" aria-label="github"  
      target="_blank"    
      rel="noopener noreferrer" >
      <i class="fab fa-github"></i>
    </a>
    
    
    

    
    <a href="https://facebook.com/lpsandaruwan1" aria-label="facebook"  
      target="_blank"    
      rel="noopener noreferrer" >
      <i class="fab fa-facebook"></i>
    </a>
    
    
    

    
    <a href="javascript:location.href = 'mailto:' + ['lpsadaruwan','gmail.com'].join('@')" aria-label="email"    >
      <i class="fas fa-envelope"></i>
    </a>
    
    
    

    
    <a href="/feed.xml" aria-label="rss"    >
      <i class="fas fa-rss"></i>
    </a>
    
    
  </div>
  <!-- .sidebar-bottom -->
</aside>
<!-- #sidebar -->
              </div>
              
              <!-- Main Content Area -->
              <div class="fm-main">
                <!-- Toolbar -->
                <div class="fm-toolbar">
                  <div class="toolbar-left">
                    <span class="toolbar-title">
                      
                        <i class="fas fa-folder"></i> Saga Pattern with serverless model on Google Cloud Platform - Part 1
                      
                    </span>
                  </div>
                  <div class="toolbar-right">
                    <!-- Search Box -->
                    <div class="search-box">
                      <input type="text" id="search-input" placeholder="Search posts..." />
                      <button id="search-btn"><i class="fas fa-search"></i></button>
                    </div>
                  </div>
                </div>
                
                <!-- File Browser Area -->
                <div class="file-browser" id="file-browser">
                  
                    <!-- Post content will be loaded in Konsole automatically -->
                  
                </div>
                
                <!-- Status Bar -->
                <div class="fm-statusbar">
                  <div class="status-left">
                     items
                  </div>
                  <div class="status-right">
                    
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- KDE Plasma Taskbar -->
      <div class="plasma-taskbar">
        <div class="taskbar-left">
          <!-- Application Menu -->
          <div class="app-menu" onclick="toggleAppMenu()">
            <div class="menu-icon">
              <i class="fab fa-linux"></i>
            </div>
          </div>
          
          <!-- Task Manager -->
          <div class="task-manager">
            <div class="task-item active" title="Dolphin">
              <i class="fas fa-folder"></i>
            </div>
          </div>
        </div>
        
        <div class="taskbar-center">
          <!-- Activities -->
        </div>
        
        <div class="taskbar-right">
          <!-- System Tray -->
          <div class="system-tray">
            <!-- Network -->
            <div class="tray-icon network-info" title="Network" onclick="toggleNetworkInfo()">
              <i class="fas fa-wifi"></i>
            </div>
            
          </div>
          
          <!-- Clock -->
          <div class="taskbar-clock" onclick="toggleCalendar()">
            <div class="clock-time" id="taskbar-time"></div>
            <div class="clock-date" id="taskbar-date"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Terminal Window (Hidden by default) -->
    <div id="terminal-window" class="terminal-window ">
      <div class="terminal-titlebar">
        <div class="terminal-title">
          <i class="fas fa-terminal"></i>
          <span id="terminal-title-text">Konsole - Saga Pattern with serverless model on Google Cloud Platform - Part 1</span>
        </div>
        <div class="window-controls">
          <div class="control minimize" onclick="closeTerminal()">âˆ’</div>
          <div class="control maximize" onclick="maximizeTerminal()">â–¡</div>
          <div class="control close" onclick="closeTerminal()">Ã—</div>
        </div>
      </div>
      
      <div class="terminal-content">
        <div class="terminal-header">
          <div class="terminal-prompt">
            <span class="user-host">user@lahiru-s-dev-journal</span>
            <span class="separator">:</span>
            <span class="path">~/posts</span>
            <span class="prompt-symbol">$</span>
            <span class="command">cat <span id="current-post-file">saga-pattern-with-serverless-model-on-google-cloud-platform-part-1.md</span></span>
          </div>
        </div>
        
        <div class="terminal-output" id="terminal-output">
          
            <!-- Direct post content with proper post layout -->
            


            
            <h1># Saga Pattern with serverless model on Google Cloud Platform - Part 1</h1>
            
            <!-- Post metadata -->
            <div class="post-meta text-muted">
              <span>
                Posted
                November 20, 2022
              </span>
              
                <span>
                  Updated
                  November 03, 2023
                </span>
              
              
              <!-- author info -->
              <div class="d-flex justify-content-between mt-2">
                <span>
                  

                  By

                  <em>
                    
                      
                        <a href="https://github.com/lpsandaruwan/">Lahiru Pathirage</a>
                        
                      
                    
                  </em>
                </span>

                <!-- read time -->
                <!-- Calculate the post's reading time, and display the word count in tooltip -->



<!-- words per minute -->










<!-- return element -->
<span
  class="readtime"
  data-bs-toggle="tooltip"
  data-bs-placement="bottom"
  title="2746 words"
>
  <em>15 min</em> read</span>

              </div>
            </div>
            
            <!-- Post content -->
            <div class="content">
              <!-- Content only - no header or metadata for plasma layout -->
<blockquote class="prompt-info">
  <p>Gostep: ðŸ‘‰ <a href="https://github.com/gostep-cli/gostep/wiki">Guide</a><br />
Materials: ðŸ‘‰ <a href="https://github.com/lpsandaruwan/saga-gcp">Complete source code</a></p>
</blockquote>

<p>During the past few years, the microservices architecture(MSA) and serverless model have gained a lot of popularity in the industry. However, these technologies come with their own set of challenges. One substantial challenge is managing data in MSA due to its complexity. Considering common patterns for MSA data management we will be focusing on the Saga pattern in this article.</p>

<h2 id="the-saga-pattern">The Saga pattern</h2>
<p>In order to manage business transactions across multiple microservices, the Saga pattern was introduced. Basically it is a series of local transactions; every transaction happens within the boundary of the micro-service, which every service will publish an event after the transaction for the next subsequent micro-service to perform the next transaction consuming the published event. This process will continue till the last transaction. In case any transaction failed in this series Saga will execute a series of fallback actions to undo the impact of all previous transactions.</p>

<p>There are two approaches to implementing the Saga pattern.</p>
<ul>
  <li>
    <p><strong>Choreography</strong> - The micro-service is responsible for emitting events eventually of its local transaction. The published event will trigger the execution of local transactions in microservices subscribed to the event. Also in this approach micro-service is responsible for handling the errors.</p>
  </li>
  <li>
    <p><strong>Orchestration</strong> - A central orchestrator(a stateful coordinator) will trigger the local transactions in services and will maintain the global transaction status including handling errors.</p>
  </li>
</ul>

<p>Now that we have a basic understanding of Saga pattern, we will discuss how to implement Saga pattern, defining an example for both approaches using Google Cloud Serverless model.</p>

<h2 id="the-real-world-example">The real world example</h2>
<p>Letâ€™s consider a train ticket booking system.</p>

<p><img src="/assets/img/content/posts/gcp-saga/flowchart.png" alt="flowchart" /></p>

<p>The workflow consists of,</p>

<ol>
  <li>Send a seat reservation request</li>
  <li>Check for available transits in the database and proceed with seat booking.</li>
  <li>Hold the number of seats until payment is processed.</li>
  <li>Process the payment.</li>
  <li>Confirm the seat booking.</li>
  <li>Confirm the reservation and notify the customer.</li>
</ol>

<p>However if the system encountered any error while running a local transaction, the fallback sequence should be executed to undo all the changes happening in the global transaction to keep the <a href="https://en.wikipedia.org/wiki/ACID">ACID</a> properties.</p>

<h2 id="preparing-the-development-environment">Preparing the development environment</h2>

<blockquote class="prompt-warning">
  <p>(Please note that we wonâ€™t be using a real payment gateway or a notification service, beacause the main purpose of this article is to demonstrate how to use severless model for Saga.)</p>
</blockquote>

<p>To implement the solution we will be using Google Cloud serverless services, MongoDb and Javascript.</p>

<p>Before we begin we must have,</p>
<ul>
  <li>A billing enabled Google Cloud project</li>
  <li>Prior knowledge in Google Cloud Services</li>
  <li>Python, NodeJs, GCloud cli tools installed in your system(If you are using Windows, WSL might come in handy)</li>
</ul>

<h3 id="google-cloud-clicloud-console">Google Cloud CLI/Cloud console</h3>
<p>You can use both CLI tools or web console to create and modify services. In this article we will be mostly using CLI tools. Please follow https://cloud.google.com/sdk/docs/install to install the Google Cloud SDK. And once you installed the SDK run <code class="language-plaintext highlighter-rouge">gcloud init</code> command and follow instructions to configure credentials.</p>

<h3 id="building-the-cloud-functions-project-structure">Building the Cloud functions project structure</h3>

<p>To build the project structure and functions, we will be using <strong>gostep</strong>, a pythonic CLI tool that I created previously to manage implementations when there are a lot of cloud functions.</p>

<p>To use gostep you need to have <strong>Subversion CLI</strong>, <strong>Python version 3</strong> and <strong>Pip</strong> package manager installed(Setup a virtual environment of your own preference). When you are ready, run the command, <code class="language-plaintext highlighter-rouge">pip install gostep</code>. For more information please refer, http://lahirus.com/gostep-intro. Also please make sure that you have enabled Cloud build APIs(https://console.cloud.google.com/apis/library/cloudbuild.googleapis.com).</p>

<p>Using <code class="language-plaintext highlighter-rouge">gostep</code>, letâ€™s first create a Cloud Functions project.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nb">mkdir </span>SagaChoreography <span class="o">&amp;&amp;</span> <span class="nb">cd </span>SagaChoreography
gostep auth init reservationsservice       <span class="c"># Creates a service account credentials file</span>
gostep base init reservations location asia-east2 version <span class="s2">"0.1.0"</span>   <span class="c"># Creates gostep project metadata files and directory structure.</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now we can have the project base. Letâ€™s move ahead with implementing local transactions and services.</p>

<h2 id="choreography-based-solution">Choreography based solution</h2>

<p>For the demonstration we will be using,</p>
<ul>
  <li>Pub/Sub for event sharing</li>
  <li>Firestore to store event data</li>
  <li>MongoDb as the transits service database</li>
</ul>

<p><img src="/assets/img/content/posts/gcp-saga/sagachoreographyflow.png" alt="saga chor flow" /></p>

<h3 id="transits-service">Transits service</h3>

<p>This micro-service is responsible for CRUD operations on train entities.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="c1">// Transit document schema</span>
  <span class="p">{</span>
       <span class="nl">transitId</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span>
       <span class="nx">trainName</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span>
       <span class="nx">start</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span>
       <span class="nx">destination</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span>
       <span class="nx">day</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span>
       <span class="nx">departure</span><span class="p">:</span> <span class="nx">number</span><span class="p">,</span>
       <span class="nx">arrival</span><span class="p">:</span> <span class="nx">number</span><span class="p">,</span>
       <span class="nx">availableSeats</span><span class="p">:</span> <span class="nx">number</span><span class="p">,</span>
       <span class="nx">lockedSeats</span><span class="p">:</span> <span class="nx">number</span><span class="p">,</span>
       <span class="nx">totalSeats</span><span class="p">:</span> <span class="nx">number</span>
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>As the database, we will be using <a href="https://console.cloud.google.com/marketplace/product/mongodb/mdb-atlas-self-service">MongoDB Atlas pay as you go</a> service in the GCP marketplace After configuring the MongoDb instance, letâ€™s create the transits function.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>gostep service init transits version <span class="s2">"0.1.0"</span> <span class="nb">env </span>nodejs
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This will create a boilerplate NodeJs cloud function in {PROJECT_ROOT}/src/transits and it can be executed as a http request after the deployment.</p>

<p>Now letâ€™s include the dependencies.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="nb">cd </span>src/transits
npm <span class="nb">install</span> <span class="nt">--save</span> mongodb
</pre></td></tr></tbody></table></code></pre></div></div>

<p>After creating the transits database and the collection, we can add MongoDb connection URI and collection name in the <code class="language-plaintext highlighter-rouge">src/trains/functions.json</code> as an environment variable.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="dl">"</span><span class="s2">environmentVariables</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
    <span class="dl">"</span><span class="s2">DB_URI</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">mongodb+srv://&lt;username&gt;:&lt;password&gt;@&lt;your-cluster-url&gt;/&lt;dbname&gt;</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">COLLECTION</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Transits</span><span class="dl">"</span>
    <span class="p">},</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>First letâ€™s use these environment variables and create a function to connect to the database.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="k">import</span> <span class="p">{</span> <span class="nx">MongoClient</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">mongodb</span><span class="dl">"</span><span class="p">;</span>
 

<span class="kd">const</span> <span class="nx">DB_URI</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">DB_URI</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">&lt;Default DB con URI&gt;</span><span class="dl">"</span><span class="p">;</span>
 
<span class="kd">const</span> <span class="nx">dbClient</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MongoClient</span><span class="p">(</span><span class="nx">DB_URI</span><span class="p">);</span>
 
<span class="kd">const</span> <span class="nx">initDbClientConnection</span> <span class="o">=</span> <span class="k">async </span><span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">await</span> <span class="nx">dbClient</span><span class="p">.</span><span class="nf">connect</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">Database failed to connect!</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>And now letâ€™s write 2 functions to find transits documents and save/update documents.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">COLLECTION</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">COLLECTION</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">Transits</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">query</span> <span class="o">=</span> <span class="k">async </span><span class="p">(</span><span class="nx">queries</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">await</span> <span class="nf">initDbClientConnection</span><span class="p">();</span>
        <span class="kd">const</span> <span class="nx">transits</span> <span class="o">=</span> <span class="nx">dbClient</span><span class="p">.</span><span class="nf">db</span><span class="p">().</span><span class="nf">collection</span><span class="p">(</span><span class="nx">COLLECTION</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">await</span> <span class="nx">transits</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="nx">queries</span><span class="p">).</span><span class="nf">toArray</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">catch </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">Failed to query transits!</span><span class="dl">"</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
        <span class="k">await</span> <span class="nx">dbClient</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">save</span> <span class="o">=</span> <span class="k">async</span><span class="p">(</span><span class="nx">transitId</span><span class="p">,</span> <span class="nx">patches</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">await</span> <span class="nf">initDbClientConnection</span><span class="p">();</span>
        <span class="kd">const</span> <span class="nx">transits</span> <span class="o">=</span> <span class="nx">dbClient</span><span class="p">.</span><span class="nf">db</span><span class="p">().</span><span class="nf">collection</span><span class="p">(</span><span class="nx">COLLECTION</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">targetData</span> <span class="o">=</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">$set</span><span class="dl">"</span><span class="p">:</span> <span class="nx">patches</span> <span class="p">};</span>
        <span class="k">await</span> <span class="nx">transits</span><span class="p">.</span><span class="nf">updateOne</span><span class="p">({</span> <span class="na">transitId</span><span class="p">:</span> <span class="nx">transitId</span> <span class="p">},</span> <span class="nx">targetData</span><span class="p">,</span> <span class="p">{</span> <span class="na">upsert</span><span class="p">:</span> <span class="kc">true</span> <span class="p">});</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">Failed to update transits!</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
        <span class="k">await</span> <span class="nx">dbClient</span><span class="p">.</span><span class="nf">close</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In the main function we map GET and PUT https methods to above functions.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="k">export</span> <span class="kd">const</span> <span class="nx">main</span> <span class="o">=</span> <span class="k">async </span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">method</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">GET</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">res</span><span class="p">.</span><span class="nf">json</span><span class="p">(</span><span class="k">await</span> <span class="nf">query</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">method</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">PUT</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">transitId</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">[</span><span class="dl">"</span><span class="s2">transitId</span><span class="dl">"</span><span class="p">];</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">transitId</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">res</span><span class="p">.</span><span class="nf">status</span><span class="p">(</span><span class="mi">400</span><span class="p">).</span><span class="nf">send</span><span class="p">({</span> <span class="dl">"</span><span class="s2">error</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Invalid parameters!</span><span class="dl">"</span> <span class="p">})</span>
        <span class="p">}</span>
        <span class="k">await</span> <span class="nf">save</span><span class="p">(</span><span class="nx">transitId</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">);</span>
        <span class="nx">res</span><span class="p">.</span><span class="nf">status</span><span class="p">(</span><span class="mi">201</span><span class="p">).</span><span class="nf">send</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">res</span><span class="p">.</span><span class="nf">status</span><span class="p">(</span><span class="mi">400</span><span class="p">).</span><span class="nf">json</span><span class="p">({</span> <span class="dl">"</span><span class="s2">error</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Invalid request</span><span class="dl">"</span> <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Great! Now we have our transits service. We can deploy it by running below command in the project root,</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>gostep deploy diff
</pre></td></tr></tbody></table></code></pre></div></div>

<p>After the deployment, transits service can be executed using http requests. But the endpoint is not available for the public. To test it locally, use the bearer token which you can obtain using the Gcloud cli.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>gcloud auth print-identity-token
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="reservations-service">Reservations service</h3>

<p>Next, we are going to implement the entrypoint of the global transaction. Like before, letâ€™s bootstrap a cloud function again. Run,</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>gostep service init reservations version <span class="s2">"0.1.0"</span> <span class="nb">env </span>nodejs
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now we have our boilerplate code in <code class="language-plaintext highlighter-rouge">{PROJECT_ROOT}/src/reservations</code>.</p>

<p>Considering this scenario the <strong>reservations</strong> function is responsible for,</p>
<ol>
  <li>Get the user request via a HTTP request.</li>
  <li>Call transits service and find out if there is any transit avaialable.</li>
  <li>If a transit is avialable publish an message to the relavent topic.</li>
  <li>Save the event data with itâ€™s status as â€˜IN_PROGRESâ€™, to update later.</li>
</ol>

<p>We are going to keep the event data stored in a database. So that we can keep the status of the particular event to use later. For that purpose we use Google Cloud firestore(data store in native mode), which is a serverless easy to use document database.
To enable Firestore run,</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>gcloud firestore databases create <span class="nt">--region</span><span class="o">=</span>asia-southeast1
</pre></td></tr></tbody></table></code></pre></div></div>

<p>After that letâ€™s install the dependencies. In the function root({PROJECT_ROOT}/src/resrevations) run,</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>npm <span class="nb">install</span> <span class="nt">--save</span> <span class="s2">"@google-cloud/firestore"</span> <span class="s2">"@google-cloud/pubsub"</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Letâ€™s assume below payload as the request JSON.</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="p">{</span>
    <span class="dl">"</span><span class="s2">day</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Monday</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">start</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Colombo</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">destination</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Ragama</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">numberOfSeats</span><span class="dl">"</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">userId</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">xyz@gmail.com</span><span class="dl">"</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Once the user made his request we have to obtain the available transits for the requested day, start position and destination of the transit. To do that we will using a HTTP request to the <strong>transits</strong> service we implemeted before. Since the transits APIs are not publically available we have to use the <code class="language-plaintext highlighter-rouge">google-auth-library</code> to authorize requests from other services(<a href="https://cloud.google.com/functions/docs/securing/authenticating">See more</a>). There is no need to add the auth library as a dependecy since it is an already included library in the cloud function runtime.</p>

<p>First letâ€™s add an environment variable for the transits API endpoint in <code class="language-plaintext highlighter-rouge">{PROJECT_ROOT}/src/transits/function.json</code>.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>    <span class="dl">"</span><span class="s2">environmentVariables</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
        <span class="dl">"</span><span class="s2">TRANSITS_API</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">{HOST_ADDRESS}/transits</span><span class="dl">"</span>
    <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>After that letâ€™s authorize our request to fetch available transits.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre><span class="k">import</span> <span class="p">{</span> <span class="nx">GoogleAuth</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">google-auth-library</span><span class="dl">"</span><span class="p">;</span>


<span class="kd">const</span> <span class="nx">TRANSITS_API</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">TRANSITS_API</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">{DEFAULT_TRANSITS_HOST_ADDRESS}/transits</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">getAvailableTransits</span> <span class="o">=</span> <span class="k">async </span><span class="p">(</span><span class="nx">numberOfSeats</span><span class="p">,</span> <span class="nx">day</span><span class="p">,</span> <span class="nx">destination</span><span class="p">,</span> <span class="nx">start</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">try</span><span class="p">{</span>
        <span class="c1">// Create an authorized client to invoke restricted Transits API.</span>
        <span class="kd">const</span> <span class="nx">auth</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GoogleAuth</span><span class="p">();</span>
        <span class="kd">const</span> <span class="nx">transitsApiClient</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">auth</span><span class="p">.</span><span class="nf">getIdTokenClient</span><span class="p">(</span><span class="nx">TRANSITS_API</span><span class="p">);</span>

        <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">transitsApiClient</span><span class="p">.</span><span class="nf">request</span><span class="p">({</span>
            <span class="na">url</span><span class="p">:</span> <span class="s2">`</span><span class="p">${</span><span class="nx">TRANSITS_API</span><span class="p">}</span><span class="s2">?day=</span><span class="p">${</span><span class="nx">day</span><span class="p">}</span><span class="s2">&amp;destination=</span><span class="p">${</span><span class="nx">destination</span><span class="p">}</span><span class="s2">&amp;start=</span><span class="p">${</span><span class="nx">start</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span>
            <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">GET</span><span class="dl">"</span>
        <span class="p">});</span>
        <span class="k">return</span> <span class="nx">result</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">element</span> <span class="o">=&gt;</span> <span class="nx">element</span><span class="p">[</span><span class="dl">"</span><span class="s2">availableSeats</span><span class="dl">"</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">numberOfSeats</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Based on the result of the API request, we proceed further. Letâ€™s assume that we got a list of available transits and we selected the topmost transit. Now we will be saving the event data in <strong>firestore</strong>, with a unique Id(a generated UUID as <code class="language-plaintext highlighter-rouge">correlationId</code>) as the global transation Id to identify the local transactions group and the status of the current event. It will aid to identify the local transaction for later references.</p>

<p>Same as before we can add the firestore collection name(reffered as <strong>kind</strong> in firestore) of the event as an environment varibale in <code class="language-plaintext highlighter-rouge">{PROJECT_ROOT}/src/transits/function.json</code>.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>    <span class="dl">"</span><span class="s2">environmentVariables</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
        <span class="dl">"</span><span class="s2">EVENT_DATA_COLLECTION</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">reservations</span><span class="dl">"</span>
    <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now we can write our function to save event data in firestore. Please note that you donâ€™t have to include configurations to authorize the connection to the firestore since the cloud function runtime has the authorized access to the firestore in the same project.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="k">import</span> <span class="nx">Firestore</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@google-cloud/firestore</span><span class="dl">"</span><span class="p">;</span>


<span class="kd">const</span> <span class="nx">EVENT_DATA_COLLECTION</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">EVENT_DATA_COLLECTION</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">reservations</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">saveEvent</span> <span class="o">=</span> <span class="k">async </span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">eventData</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">firestore</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Firestore</span><span class="p">();</span>
        <span class="kd">const</span> <span class="nx">docRef</span> <span class="o">=</span> <span class="nx">firestore</span><span class="p">.</span><span class="nf">collection</span><span class="p">(</span><span class="nx">EVENT_DATA_COLLECTION</span><span class="p">).</span><span class="nf">doc</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
        <span class="k">await</span> <span class="nx">docRef</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">eventData</span><span class="p">,</span> <span class="p">{</span> <span class="na">merge</span><span class="p">:</span> <span class="kc">true</span> <span class="p">});</span>
        <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">docRef</span><span class="p">.</span><span class="nf">get</span><span class="p">()</span>
        <span class="k">return</span> <span class="nx">result</span><span class="p">.</span><span class="nx">exists</span><span class="p">?</span> <span class="nx">result</span><span class="p">.</span><span class="nf">data</span><span class="p">():</span> <span class="p">{};</span> <span class="c1">// return the updated doc for later references</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">Error saving event data!</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>And since we have assumed that we have an available transit, we are going to publish a message to a pubsub topic to trigger the next event, <strong>bookings</strong>. First letâ€™s create a topic for this purpose.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>gcloud pubsub topics create reservations.bookings
</pre></td></tr></tbody></table></code></pre></div></div>

<p>And please copy the output of that command and keep it saved, we are going to need it later. Same as before letâ€™s have another environment varible for the topic name and wirte the function to publish the message. In the message we include <code class="language-plaintext highlighter-rouge">correlationId</code>, <code class="language-plaintext highlighter-rouge">numberOfSeats</code>, <code class="language-plaintext highlighter-rouge">transitId</code> and <code class="language-plaintext highlighter-rouge">userId</code>.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="k">import</span> <span class="p">{</span> <span class="nx">PubSub</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@google-cloud/pubsub</span><span class="dl">"</span><span class="p">;</span>


<span class="kd">const</span> <span class="nx">BOOKINGS_TOPIC</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">BOOKINGS_TOPIC</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">reservations.bookings</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">publishMessage</span> <span class="o">=</span> <span class="k">async </span><span class="p">(</span><span class="nx">topic</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">pubsubClient</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PubSub</span><span class="p">();</span>
        <span class="kd">const</span> <span class="nx">dataBuffer</span> <span class="o">=</span> <span class="nx">Buffer</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nf">stringify</span><span class="p">(</span><span class="nx">message</span><span class="p">));</span>
        <span class="k">return</span> <span class="k">await</span> <span class="nx">pubsubClient</span><span class="p">.</span><span class="nf">topic</span><span class="p">(</span><span class="nx">topic</span><span class="p">)</span>
            <span class="p">.</span><span class="nf">publishMessage</span><span class="p">({</span> <span class="na">data</span><span class="p">:</span> <span class="nx">dataBuffer</span> <span class="p">});</span>
    <span class="p">}</span> <span class="k">catch </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="s2">`Error publishing message to </span><span class="p">${</span><span class="nx">topic</span><span class="p">}</span><span class="s2">!`</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now we have all helper functions and we can write the logic in the main funtion. Once the function is complted to deploy run,</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>gostep deploy diff
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="bookings-service">Bookings service</h3>

<p>The <strong>bookings</strong> function is responsible for hold the requested number of seats in selected transit until the global transaction is finished. The acting trigger of the function will be the <code class="language-plaintext highlighter-rouge">reservations.bookings</code> pubsub topic we create during the previous step. Once this service successfully locked the request number of seats it will publish a message to the relevenat pubsub topic to trigger the <strong>payments</strong> function.</p>

<p>Letâ€™s start. To initialize the function run,</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>gostep service init bookings version <span class="s2">"0.1.0"</span> <span class="nb">env </span>nodejs trigger pubsub
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now we have bootstrapped our cloud function in <code class="language-plaintext highlighter-rouge">{PROJECT_ROOT/src/bookings</code>. Letâ€™s tell the funtion that it will triggered by the <code class="language-plaintext highlighter-rouge">reservations.bookings</code> topic. For that we can include the resource value we copied from the previous topic creation in the <code class="language-plaintext highlighter-rouge">{PROJECT_ROOT/src/bookings/function.json</code>.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>    <span class="dl">"</span><span class="s2">eventTrigger</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
        <span class="dl">"</span><span class="s2">eventType</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">providers/cloud.pubsub/eventTypes/topic.publish</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">resource</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">projects/{GCLOUD_PROJECT_ID}/topics/reservations.bookings</span><span class="dl">"</span>
    <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Same as the <strong>reservations</strong> function, we need to save the local transactionâ€™s event data with the <code class="language-plaintext highlighter-rouge">correlationId</code> and the <code class="language-plaintext highlighter-rouge">status</code> as <code class="language-plaintext highlighter-rouge">IN_PROGRESS</code> for later references. Also we can use same functions from the previous service to authorize requests to <strong>transits</strong> service and to publish the message to the next topic. What we can do is update the transit document to lock the requested number of seats.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre><span class="k">import</span> <span class="p">{</span> <span class="nx">GoogleAuth</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">google-auth-library</span><span class="dl">"</span><span class="p">;</span>


<span class="kd">const</span> <span class="nx">TRANSITS_API</span> <span class="o">=</span> <span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">TRANSITS_API</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">{TRANSITS_API_HOST}/transits</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">getTransitsById</span> <span class="o">=</span> <span class="k">async </span><span class="p">(</span><span class="nx">transitId</span><span class="p">,</span> <span class="nx">client</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">client</span><span class="p">.</span><span class="nf">request</span><span class="p">({</span>
            <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">GET</span><span class="dl">'</span><span class="p">,</span>
            <span class="na">url</span><span class="p">:</span> <span class="s2">`</span><span class="p">${</span><span class="nx">TRANSITS_API</span><span class="p">}</span><span class="s2">?transitId=</span><span class="p">${</span><span class="nx">transitId</span><span class="p">}</span><span class="s2">`</span>
        <span class="p">});</span>
        <span class="k">return</span> <span class="nx">result</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">?</span> <span class="nx">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="p">{};</span>
    <span class="p">}</span> <span class="k">catch </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nc">Error</span><span class="p">(</span><span class="s2">`Error fetching transit data: </span><span class="p">${</span><span class="nx">transitId</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">updateTransitsById</span> <span class="o">=</span> <span class="k">async </span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">newData</span><span class="p">,</span> <span class="nx">client</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">try</span><span class="p">{</span>
        <span class="k">return</span> <span class="k">await</span> <span class="nx">client</span><span class="p">.</span><span class="nf">request</span><span class="p">({</span>
            <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">PUT</span><span class="dl">"</span><span class="p">,</span>
            <span class="na">url</span><span class="p">:</span> <span class="s2">`</span><span class="p">${</span><span class="nx">TRANSITS_API</span><span class="p">}</span><span class="s2">?transitId=</span><span class="p">${</span><span class="nx">id</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span>
            <span class="na">body</span><span class="p">:</span> <span class="nx">newData</span>
        <span class="p">});</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="k">export</span> <span class="kd">const</span> <span class="nx">main</span> <span class="o">=</span> <span class="k">async </span><span class="p">(</span><span class="nx">eventData</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">transactionData</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="nf">atob</span><span class="p">(</span><span class="nx">eventData</span><span class="p">.</span><span class="nx">data</span><span class="p">));</span> <span class="c1">// Extract data from pubsub message</span>

    <span class="kd">const</span> <span class="nx">correlationId</span> <span class="o">=</span> <span class="nx">transactionData</span><span class="p">[</span><span class="dl">"</span><span class="s2">correlationId</span><span class="dl">"</span><span class="p">];</span>
    <span class="kd">const</span> <span class="nx">numberOfSeats</span> <span class="o">=</span> <span class="nc">Number</span><span class="p">(</span><span class="nx">transactionData</span><span class="p">[</span><span class="dl">"</span><span class="s2">numberOfSeats</span><span class="dl">"</span><span class="p">]);</span>
    <span class="kd">const</span> <span class="nx">transitId</span> <span class="o">=</span> <span class="nx">transactionData</span><span class="p">[</span><span class="dl">"</span><span class="s2">transitId</span><span class="dl">"</span><span class="p">];</span>
    <span class="kd">const</span> <span class="nx">userId</span> <span class="o">=</span> <span class="nx">transactionData</span><span class="p">[</span><span class="dl">"</span><span class="s2">userId</span><span class="dl">"</span><span class="p">];</span>

    <span class="kd">const</span> <span class="nx">auth</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GoogleAuth</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">transitsApiClient</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">auth</span><span class="p">.</span><span class="nf">getIdTokenClient</span><span class="p">(</span><span class="nx">TRANSITS_API</span><span class="p">);</span>

    <span class="kd">const</span> <span class="nx">transit</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">getTransitsById</span><span class="p">(</span><span class="nx">transitId</span><span class="p">,</span> <span class="nx">transitsApiClient</span><span class="p">);</span>
    <span class="k">await</span> <span class="nf">updateTransitsById</span><span class="p">(</span><span class="nx">transitId</span><span class="p">,</span> <span class="p">{</span>
                <span class="dl">"</span><span class="s2">lockedSeats</span><span class="dl">"</span><span class="p">:</span> <span class="nx">transit</span><span class="p">[</span><span class="dl">"</span><span class="s2">lockedSeats</span><span class="dl">"</span><span class="p">]</span> <span class="o">+</span> <span class="nx">numberOfSeats</span><span class="p">,</span>
                <span class="dl">"</span><span class="s2">availableSeats</span><span class="dl">"</span><span class="p">:</span> <span class="nx">transit</span><span class="p">[</span><span class="dl">"</span><span class="s2">availableSeats</span><span class="dl">"</span><span class="p">]</span> <span class="o">-</span> <span class="nx">numberOfSeats</span>
                <span class="p">},</span> <span class="nx">transitsApiClient</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>And like before we will be creating the next pubsub topic to publish the message from <strong>bookings</strong>.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>gcloud pubsub topics create reservations.payments
</pre></td></tr></tbody></table></code></pre></div></div>

<p>After a successful seat locking, we will be publishing a message with <code class="language-plaintext highlighter-rouge">correlationId</code>, <code class="language-plaintext highlighter-rouge">numberOfClients</code> and <code class="language-plaintext highlighter-rouge">userId</code>.</p>

<p>Once the function has been completed we can deploy it using,</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>gostep deploy diff
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Great! Now we have covered common functionalities,</p>
<ul>
  <li>Consume HTTP requests</li>
  <li>Function to function direct communication(via HTTP)</li>
  <li>Read and update event data in firestore</li>
  <li>Publishing and subscribing to Pubsub topics</li>
</ul>

<p>This is more than enough for us to implement next services. Therefor afterwards, I will be explaining the functionâ€™s role only.</p>

<h3 id="payments-service">Payments service</h3>

<p>The payments service will consume the message from <code class="language-plaintext highlighter-rouge">reservations.payments</code> and publish a message to <code class="language-plaintext highlighter-rouge">reservations.bookingCompletions</code> or <code class="language-plaintext highlighter-rouge">reservations.bookingCancelletions</code> accordingly for a successful payment or for a failed payment.</p>

<h3 id="booking-completions-service">Booking completions service</h3>

<p>The booking completions will be consuming the messages from <code class="language-plaintext highlighter-rouge">reservations.bookingCompletions</code> topic, will be update the transit as the seat booking is completed and after that will update previously saved <strong>booking</strong> eventâ€™s status from <code class="language-plaintext highlighter-rouge">IN_PROGRESS</code> to <code class="language-plaintext highlighter-rouge">COMPLETED</code> for the relevant <code class="language-plaintext highlighter-rouge">correlationId</code>. Then the service will publish an message to the <code class="language-plaintext highlighter-rouge">reservations.reservationCompletions</code> topic.</p>

<h3 id="booking-cancellations-service">Booking cancellations service</h3>

<p>In the event of a payment failure, after consuming the message from the topic <code class="language-plaintext highlighter-rouge">reservations.bookingCancelletions</code> this function will rollback the locked seats in the relevant transit, will update <strong>booking</strong> eventâ€™s status from <code class="language-plaintext highlighter-rouge">IN_PROGRESS</code> to <code class="language-plaintext highlighter-rouge">FAILED</code> for the relevant <code class="language-plaintext highlighter-rouge">correlationId</code> and will pass the <code class="language-plaintext highlighter-rouge">correlationId</code> to the <code class="language-plaintext highlighter-rouge">reservations.reservationCancellations</code> topic.</p>

<h3 id="reservation-completions-service">Reservation completions service</h3>

<p>As the final step of a completed series of events the <strong>reservation completions service</strong> will consume the correlation id for the transaction from <code class="language-plaintext highlighter-rouge">reservations.reservationCompletions</code> and will update previously saved <code class="language-plaintext highlighter-rouge">reservations</code> eventâ€™s status from <code class="language-plaintext highlighter-rouge">IN_PROGRESS</code> to <code class="language-plaintext highlighter-rouge">COMPLETED</code>. After that a message will be published to the <code class="language-plaintext highlighter-rouge">reservations.notifications</code> topic to send the successful transaction notifications to the customer.</p>

<h3 id="reservation-cancellations-service">Reservation cancellations service</h3>

<p>Consuming the message from <code class="language-plaintext highlighter-rouge">reservations.reservationCancellations</code> this function will update previously saved <code class="language-plaintext highlighter-rouge">reservations</code> eventâ€™s status from <code class="language-plaintext highlighter-rouge">IN_PROGRESS</code> to <code class="language-plaintext highlighter-rouge">FAILED</code> and will publish a message to the <code class="language-plaintext highlighter-rouge">reservations.notifications</code> topic to send the failed transaction notifications status to the customer.</p>

<h2 id="securing-the-entrypoint">Securing the entrypoint</h2>

<p>After deploying all the services we can use Google API gateway to secure our <code class="language-plaintext highlighter-rouge">reservations</code> entrypoint of the transaction.
Please refer <a href="https://cloud.google.com/api-gateway/docs/secure-traffic-gcloud">API gatewey quickstart</a>.</p>

<p>ðŸ¦– Letâ€™s look into <strong>Orchestration</strong> based solution in the next article.</p>


            </div>
            
            <!-- Post metadata and social sharing -->
            <div class="post-tail-wrapper text-muted">
              <!-- categories -->
              
                <div class="post-meta mb-3">
                  <i class="far fa-folder-open fa-fw me-1"></i>
                  
                    <a href="/categories/posts/">Posts</a>,
                    <a href="/categories/serverless/">Serverless</a>
                </div>
              

              <!-- tags -->
              
                <div class="post-tags">
                  <i class="fa fa-tags fa-fw me-1"></i>
                  
                    <a href="/tags/gcp/" class="post-tag no-text-decoration">gcp</a>
                  
                    <a href="/tags/serverless/" class="post-tag no-text-decoration">serverless</a>
                  
                    <a href="/tags/saga/" class="post-tag no-text-decoration">saga</a>
                  
                    <a href="/tags/choreography/" class="post-tag no-text-decoration">choreography</a>
                  
                    <a href="/tags/gostep/" class="post-tag no-text-decoration">gostep</a>
                  
                </div>
              

              <div class="post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2">
                <div class="license-wrapper">
                  


                  
                    
                    This post is licensed under 
                      <a href="https://creativecommons.org/licenses/by/4.0/">
                        CC BY 4.0
                      </a>
                     by the author.
                  
                </div>

                <!-- Post sharing snippet -->

<div class="share-wrapper d-flex align-items-center">
  <span class="share-label text-muted me-1">Share</span>
  <span class="share-icons">
    
    
    

    
      
      <a
        href="https://twitter.com/intent/tweet?text=Saga%20Pattern%20with%20serverless%20model%20on%20Google%20Cloud%20Platform%20-%20Part%201%20-%20Lahiru's%20dev%20journal&url=%2Fposts%2Fsaga-gcp-choreography%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Twitter"
        target="_blank"
        rel="noopener"
        aria-label="Twitter"
      >
        <i class="fa-fw fa-brands fa-square-x-twitter"></i>
      </a>
    
      
      <a
        href="https://www.facebook.com/sharer/sharer.php?title=Saga%20Pattern%20with%20serverless%20model%20on%20Google%20Cloud%20Platform%20-%20Part%201%20-%20Lahiru's%20dev%20journal&u=%2Fposts%2Fsaga-gcp-choreography%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Facebook"
        target="_blank"
        rel="noopener"
        aria-label="Facebook"
      >
        <i class="fa-fw fab fa-facebook-square"></i>
      </a>
    
      
      <a
        href="https://t.me/share/url?url=%2Fposts%2Fsaga-gcp-choreography%2F&text=Saga%20Pattern%20with%20serverless%20model%20on%20Google%20Cloud%20Platform%20-%20Part%201%20-%20Lahiru's%20dev%20journal"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Telegram"
        target="_blank"
        rel="noopener"
        aria-label="Telegram"
      >
        <i class="fa-fw fab fa-telegram"></i>
      </a>
    

    <button
      id="copy-link"
      aria-label="Copy link"
      class="btn small"
      data-bs-toggle="tooltip"
      data-bs-placement="top"
      title="Copy link"
      data-title-succeed="Link copied successfully!"
    >
      <i class="fa-fw fas fa-link pe-none"></i>
    </button>
  </span>
</div>

              </div>
            </div>
            
            <!-- Comments section -->
            
              <div class="post-comments">
                
                    <!-- The Disqus lazy loading. -->

<div id="disqus_thread">
  <p class="text-center text-muted small">Comments powered by <a href="https://disqus.com/">Disqus</a>.</p>
</div>

<script type="text/javascript">
  var disqus_config = function () {
    this.page.url = '/posts/saga-gcp-choreography/';
    this.page.identifier = '/posts/saga-gcp-choreography/';
  };

  /* Lazy loading */
  var disqus_observer = new IntersectionObserver(
    function (entries) {
      if (entries[0].isIntersecting) {
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = 'https://lpsandaruwan.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();

        disqus_observer.disconnect();
      }
    },
    { threshold: [0] }
  );

  disqus_observer.observe(document.querySelector('#disqus_thread'));

  /* Auto switch theme */
  function reloadDisqus() {
    if (event.source === window && event.data && event.data.direction === ModeToggle.ID) {
      /* Disqus hasn't been loaded */
      if (typeof DISQUS === 'undefined') {
        return;
      }

      if (document.readyState == 'complete') {
        DISQUS.reset({ reload: true, config: disqus_config });
      }
    }
  }

  if (document.querySelector('.mode-toggle')) {
    window.addEventListener('message', reloadDisqus);
  }
</script>

                  
              </div>
            
          
        </div>
        
        <div class="terminal-prompt">
          <span class="user-host">user@lahiru-s-dev-journal</span>
          <span class="separator">:</span>
          <span class="path">~/posts</span>
          <span class="prompt-symbol">$</span>
          <span class="cursor"> </span>
        </div>
      </div>
    </div>

    <!-- Application Menu (Hidden by default) -->
    <div id="app-menu" class="app-menu-panel hidden">
      <div class="menu-section">
        <div class="menu-title">Navigation</div>
        <a href="/archives/" class="menu-item">
          <i class="fas fa-file-archive"></i>
          <span>Ark</span>
        </a>
        <a href="/projects/" class="menu-item">
          <i class="fas fa-chart-area"></i>
          <span>KSysGuard</span>
        </a>
      </div>
    </div>


    <!-- Network Info Panel (Hidden by default) -->
    <div id="network-info" class="app-menu-panel hidden">
      <div class="menu-section">
        <div class="menu-title">Network Information</div>
        <div class="network-details">
          <div class="network-item">
            <i class="fas fa-globe"></i>
            <span>IP Address: <span id="ip-address">Loading...</span></span>
          </div>
          <div class="network-item">
            <i class="fas fa-wifi"></i>
            <span>Connection: <span id="connection-type">WiFi</span></span>
          </div>
          <div class="network-item">
            <i class="fas fa-server"></i>
            <span>Location: <span id="location">Loading...</span></span>
          </div>
          <div class="network-item">
            <i class="fas fa-shield-alt"></i>
            <span>ISP: <span id="isp">Loading...</span></span>
          </div>
        </div>
      </div>
    </div>

    <!-- Overlay -->
    <div id="overlay" class="overlay " onclick="closeAllPanels()"></div>

    <!-- Search Data -->
    <script>
      window.searchData = [
        
        {
          title: "I've Noticed AI Tools Generate Terrible REST APIs - Here's How to Fix It",
          content: "Here's something that bugs me: AI tools like ChatGPT, Claude, Gemini, or whatever AI you're using are great at cranking out code fast,\nbut they often generate REST APIs that look like they were designed by someone who never had to maintain them.\n\nOver the past few years working with different teams, I've noticed that about most of AI generated APIs have naming conventions that make me question everything.\n\n\n\nWhy does this happen? AI models learn from existing code on the internet, and unfortu...",
          url: "/posts/ive-noticed-ai-tools-generate-terrible-rest-apis/",
          date: "July 10, 2025",
          categories: ["Posts","REST","API designing","Software Engineering","AI Assisted coding"],
          excerpt: "Hereâ€™s something that bugs me: AI tools like ChatGPT, Claude, Gemini, or whatever AI youâ€™re using...",
          icon: "fas fa-file-alt"
        },
        
        {
          title: "Arch Linux for Developers: A Step-by-Step Guide to Building Your Ultimate Dev Environment",
          content: "![arch logo](/assets/img/content/posts/arch/arch.png)\n\n## Why Arch Linux? Let's Jump In!\n\nHey there, fellow developer community! If you've been browsing Linux distributions, you know there are **tons** of options out there. I've tested a few, gone on some Linux adventures, and finally landed on Arch Linux. And, wow, itâ€™s been my go-to for over 11 years now. If you want a powerful development setup and want to learn Linux hands-on, Arch could be your golden ticket. Letâ€™s explore why!\n\n## Start...",
          url: "/posts/archlinux-2024-guide/",
          date: "October 27, 2024",
          categories: ["Posts","Linux","OS","Development"],
          excerpt: "\n",
          icon: "fab fa-linux"
        },
        
        {
          title: "GrooveCraft: Building Your Own Amplifier for Next-Level Music Vibes",
          content: "> People have different preferences when it comes to how they like to listen to music, and the sound experience can be different for each person. Here, I've put together my findings on creating an affordable do-it-yourself sound system that suits my taste.\n{: .prompt-warning }\n\n![wave_graph_nero_forte_slipknot](/assets/img/content/posts/diy-amp/wave-nero-forte.png)\n\n## What Makes Sound Good?\n\nOkay, so everyone's got their own taste in sound. Some love the deep, thumping bass that makes your h...",
          url: "/posts/crafting-audio-ecosystem/",
          date: "December 23, 2023",
          categories: ["Posts","Audio","Hobby","Music"],
          excerpt: "\n  People have different preferences when it comes to how they like to listen to music, and the s...",
          icon: "fas fa-music"
        },
        
        {
          title: "Saga Pattern with serverless model on Google Cloud Platform - Part 1",
          content: "\n  Gostep: ðŸ‘‰ Guide\nMaterials: ðŸ‘‰ Complete source code\n\n\nDuring the past few years, the microservices architecture(MSA) and serverless model have gained a lot of popularity in the industry. However, these technologies come with their own set of challenges. One substantial challenge is managing data in MSA due to its complexity. Considering common patterns for MSA data management we will be focusing on the Saga pattern in this article.\n\nThe Saga pattern\nIn order to manage business transactions a...",
          url: "/posts/saga-gcp-choreography/",
          date: "November 20, 2022",
          categories: ["Posts","Serverless"],
          excerpt: "\n  Gostep: ðŸ‘‰ Guide\nMaterials: ðŸ‘‰ Complete source code\n\n\nDuring the past few years, the microservic...",
          icon: "fas fa-file-alt"
        },
        
        {
          title: "Super charge a Google cloud functions project",
          content: "\nWhen developing a microservices project with cloud functions, managing the cluster of functions all of them together can be a pain in the ass. That is why I thought of developing a simple cli tool to super charge the development and deployment process.\n\nI named this little Pythonic tool as gostep a.k.a serverless templates provider for Google cloud platform. However this tool is still taking the baby steps. Hope to develop this to be more useful in future releases.\n\nI would like to show you ...",
          url: "/posts/gostep-intro/",
          date: "June 19, 2020",
          categories: ["Projects","DevOps"],
          excerpt: "\nWhen developing a microservices project with cloud functions, managing the cluster of functions ...",
          icon: "fas fa-project-diagram"
        },
        
        {
          title: "Application Deployment in Apache Tomcat on GCE Using Ansible",
          content: "Think about a person who needs a cloud instance temporarily to deploy a web application to do tests frequently and throughout the time he deploys the application,\nuse it for a while and then deletes the instance to save the cost.\nOr someone needs to create a cluster, thus he needs to instantiate several cloud servers at once,\ninstall dependencies and deploy the application on each server. Doing these tasks by hand costs much effort and it is inefficient.\nThe way to make such scenarios easier,...",
          url: "/posts/tomcat-gce-ansible-demo/",
          date: "March 01, 2018",
          categories: ["Posts","DevOps"],
          excerpt: "Think about a person who needs a cloud instance temporarily to deploy a web application to do tes...",
          icon: "fas fa-file-alt"
        },
        
        {
          title: "Setting up Creative Labs USB DAC volume knob on Linux",
          content: "Lately I bought a Creative Labs SB1095, a 5.1 USB DAC for my laptop.\nThis USB sound card works perfectly on Linux.\nThe sound quality is better than the integrated,\nbut it has a volume knob on it and a remote controller,\nwhich does not support out of the box by Linux distributions which I have tried(Ubuntu, Linux Mint, OpenSuse, Arch Linux).\nAfter digging up the internet a little bit I perceived that it is required to configure a software volume controller to handle the volume knob.\nHowever, I...",
          url: "/posts/sb1095-volume-knob-linux/",
          date: "May 11, 2017",
          categories: ["Posts","Linux"],
          excerpt: "Lately I bought a Creative Labs SB1095, a 5.1 USB DAC for my laptop.\nThis USB sound card works pe...",
          icon: "fab fa-linux"
        },
        
        {
          title: "Continuous Code Quality On My OpenSource Project",
          content: "Good quality in code plays an essential role when it comes to software,\nthus it assets efficiency, reliability, robustness, portability, maintainability and readability like essential factors.\nConsidering a GitHub project, there are plenty of options to measure code quality.\nConsidering options I would like to chose SonarQube for this particular purpose.\nLet me take down the steps, how I used SonarQube to measure code quality using a Java project, one of my GitHub hosted projects, Depli.\n\nNB:...",
          url: "/posts/github-sonarqube/",
          date: "April 20, 2017",
          categories: ["Posts","DevOps"],
          excerpt: "Good quality in code plays an essential role when it comes to software,\nthus it assets efficiency...",
          icon: "fas fa-file-alt"
        },
        
        {
          title: "Continuous listening to remote text files using python",
          content: "Log Tracker is a simple wrapper around Python paramiko to track text files using SSH.\nIt gives you the ability to create custom python functions to track and analyze log files the way you want.\nA user can access the contents in multiple log files at the same time also.\nUsing a custom function a user can display a log content in a web interface using Flask like lightweight web service,\nso then anyone can analyze contents easily, without wasting time to login into servers and download contents....",
          url: "/posts/log-tracker/",
          date: "April 14, 2017",
          categories: ["Projects","DevOps"],
          excerpt: "Log Tracker is a simple wrapper around Python paramiko to track text files using SSH.\nIt gives yo...",
          icon: "fas fa-project-diagram"
        },
        
        {
          title: "Depli - A JVM monitor application",
          content: "Depli provides you the 10-second solution for monitoring JVMs. Just add a JMX remote connection using webUI and see how it works.\nDepli provides you a rich UI, you can even search for running threads, classpaths etc.\nThis handsome tool has been released under GPL license on GitHub.\n\n\n\nWebsite: https://lahirus.com/depli\n\nWiki: https://github.com/lpsandaruwan/depli/wiki\n\nLicense: GPLv3 or later\n\nSource code: https://github.com/lpsandaruwan/depli\n\nReleases: https://github.com/lpsandaruwan/depli/...",
          url: "/posts/depli/",
          date: "April 03, 2017",
          categories: ["Projects","DevOps"],
          excerpt: "Depli provides you the 10-second solution for monitoring JVMs. Just add a JMX remote connection u...",
          icon: "fas fa-project-diagram"
        },
        
        {
          title: "JVM CPU usage using Java MXBeans",
          content: "This is a solution to a problem, occurred to me while developing Depli a JVM monitoring dashboard which uses JMX remote connections.\nThere is no way to get the JVM CPU usage directly using MXBeans in JDKs older than version 7. For my application I wanted a universal method.\nFinally, I got it working thanks to source code of jconsole.\n\nExplanation\n\nIdeal solution to calculate CPU usage is periodically look at the idle time and get the time that JVM is not idle.\nBut there is no method to expose...",
          url: "/posts/jvm-cpu-usage/",
          date: "February 26, 2017",
          categories: ["Posts","Other"],
          excerpt: "This is a solution to a problem, occurred to me while developing Depli a JVM monitoring dashboard...",
          icon: "fas fa-file-alt"
        },
        
        {
          title: "Savior ship - A cross flatform C++ game",
          content: "Savior Ship is a simple 2D shooter game implemented using C++ and simple direct media layer version 2(SDL2),\nThis is the way I attempted to refresh my skills on C++. Savior ship has been released under GPL license in GitHub for the purpose\nof helping out the people who seek SDL2 beginner level applications to learn.\n\n\n\nWebsite: https://lahirus.com/savior-ship\n\nLicense: GPLv3 or later\n\nSource code: https://github.com/lpsandaruwan/savior-ship\n\nReleases: https://github.com/lpsandaruwan/savior-sh...",
          url: "/posts/savior-ship/",
          date: "February 23, 2017",
          categories: ["Projects","Gaming"],
          excerpt: "Savior Ship is a simple 2D shooter game implemented using C++ and simple direct media layer versi...",
          icon: "fas fa-project-diagram"
        },
        
        {
          title: "Surgeon Tux - A Jekyll template",
          content: "Surgeon Tux is a GPL(v3) licensed free Jekyll template meant for terminal lovers.\nI tried my best to give it the appearance of a terminal.\n\nWhere can I find the source code?\nSurgeon Tux code is hosted in a github repository, you can obtain it from https://github.com/lpsandaruwan/surgeon-tux\n\nHow to use it?\n\nFirst clone the surgeon tux,\n\ngit clone https://github.com/lpsandaruwan/surgeon-tux.git\ncd surgeon-tux\n\nMake sure you have installed RubyGems package manager,\n\ngem install jekyll\ngem insta...",
          url: "/posts/surgeon-tux/",
          date: "February 23, 2017",
          categories: ["Projects","Other"],
          excerpt: "Surgeon Tux is a GPL(v3) licensed free Jekyll template meant for terminal lovers.\nI tried my best...",
          icon: "fas fa-project-diagram"
        },
        
        {
          title: "Traverse through font design timeline",
          content: "KalaGola is a cross platform Pythonic tool to traverse through the timeline of your GitHub hosted font repository,\nand generate a video file to show how your font evolved through time. Just provide your custom web template and\nrepository information as a YAML file or as command line arguments, KalaGola will serve you your video.\n\n\n\nHow does it work?\nKalaGola uses weasyprint to capture html snapshots after checking out each and every commit made on a specific\nfont file and copying the font fil...",
          url: "/posts/kalagola/",
          date: "January 26, 2017",
          categories: ["Projects","Other"],
          excerpt: "KalaGola is a cross platform Pythonic tool to traverse through the timeline of your GitHub hosted...",
          icon: "fas fa-project-diagram"
        }
        
      ];
    </script>

    <!-- Scripts -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Switch the mode between dark and light. -->

<script type="text/javascript">
  class ModeToggle {
    static get MODE_KEY() {
      return 'mode';
    }
    static get MODE_ATTR() {
      return 'data-mode';
    }
    static get DARK_MODE() {
      return 'dark';
    }
    static get LIGHT_MODE() {
      return 'light';
    }
    static get ID() {
      return 'mode-toggle';
    }

    constructor() {
      if (this.hasMode) {
        if (this.isDarkMode) {
          if (!this.isSysDarkPrefer) {
            this.setDark();
          }
        } else {
          if (this.isSysDarkPrefer) {
            this.setLight();
          }
        }
      }

      let self = this;

      /* always follow the system prefers */
      this.sysDarkPrefers.addEventListener('change', () => {
        if (self.hasMode) {
          if (self.isDarkMode) {
            if (!self.isSysDarkPrefer) {
              self.setDark();
            }
          } else {
            if (self.isSysDarkPrefer) {
              self.setLight();
            }
          }

          self.clearMode();
        }

        self.notify();
      });
    } /* constructor() */

    get sysDarkPrefers() {
      return window.matchMedia('(prefers-color-scheme: dark)');
    }

    get isSysDarkPrefer() {
      return this.sysDarkPrefers.matches;
    }

    get isDarkMode() {
      return this.mode === ModeToggle.DARK_MODE;
    }

    get isLightMode() {
      return this.mode === ModeToggle.LIGHT_MODE;
    }

    get hasMode() {
      return this.mode != null;
    }

    get mode() {
      return sessionStorage.getItem(ModeToggle.MODE_KEY);
    }

    /* get the current mode on screen */
    get modeStatus() {
      if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) {
        return ModeToggle.DARK_MODE;
      } else {
        return ModeToggle.LIGHT_MODE;
      }
    }

    setDark() {
      document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE);
      sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE);
    }

    setLight() {
      document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE);
      sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE);
    }

    clearMode() {
      document.documentElement.removeAttribute(ModeToggle.MODE_ATTR);
      sessionStorage.removeItem(ModeToggle.MODE_KEY);
    }

    /* Notify another plugins that the theme mode has changed */
    notify() {
      window.postMessage(
        {
          direction: ModeToggle.ID,
          message: this.modeStatus
        },
        '*'
      );
    }

    flipMode() {
      if (this.hasMode) {
        if (this.isSysDarkPrefer) {
          if (this.isLightMode) {
            this.clearMode();
          } else {
            this.setLight();
          }
        } else {
          if (this.isDarkMode) {
            this.clearMode();
          } else {
            this.setDark();
          }
        }
      } else {
        if (this.isSysDarkPrefer) {
          this.setLight();
        } else {
          this.setDark();
        }
      }

      this.notify();
    } /* flipMode() */
  } /* ModeToggle */

  const modeToggle = new ModeToggle();
</script>

    
    <!-- Load theme system JavaScript -->
    <script src="/assets/js/dist/commons.min.js"></script>
    
    <script src="/assets/js/plasma-desktop.js"></script>
    
    
    <!-- Auto-populate post data for Konsole -->
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const terminal = document.getElementById('terminal-window');
        if (terminal) {
          terminal.dataset.currentPostUrl = '/posts/saga-gcp-choreography/';
          // Update task manager for opened terminal
          updateTaskManager();
        }
      });
    </script>
    
  </body>
</html>

